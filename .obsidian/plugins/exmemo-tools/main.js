/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var er = Object.defineProperty;
var ca = Object.getOwnPropertyDescriptor;
var ua = Object.getOwnPropertyNames;
var da = Object.prototype.hasOwnProperty;
var ma = (r, e) => {
    for (var t in e) er(r, t, { get: e[t], enumerable: !0 });
  },
  fa = (r, e, t, n) => {
    if ((e && typeof e == "object") || typeof e == "function")
      for (let s of ua(e))
        !da.call(r, s) &&
          s !== t &&
          er(r, s, {
            get: () => e[s],
            enumerable: !(n = ca(e, s)) || n.enumerable,
          });
    return r;
  };
var ha = (r) => fa(er({}, "__esModule", { value: !0 }), r);
var $i = {};
ma($i, { default: () => Zn });
module.exports = ha($i);
var Je = require("obsidian");
var ns = require("obsidian");
var tr = {
  confirm: "Confirm",
  yes: "Yes",
  no: "No",
  llmLoading: "LLM is thinking...",
  noResult: "LLM no result",
  pleaseOpenFile: "Please open a file first",
  llmError: "An error occurred, please try again later",
  inputPrompt: "Please enter the prompt",
  chatButton: "Chat",
  pleaseSelectText: "Please select the text to be processed first",
  currentFileNotMarkdown: "The current file is not a markdown file",
  fileAlreadyContainsTagsAndDescription:
    "The file already contains tags and description",
  parseError: "Failed to parse the returned result",
  metaUpdated: "Meta data updated",
  llmSettings: "LLM",
  apiKey: "API key",
  baseUrl: "Base URL",
  modelName: "Model name",
  metaSetting: "Meta",
  metaSettingDesc: "Automatically generate file metadata",
  metaUpdateSetting: "Update meta",
  updateMetaOptions: "Update",
  updateMetaOptionsDesc: "If meta already exists, choose whether to regenerate",
  updateForce: "Force update existing items",
  updateNoLLM: "Only update items that do not use LLM",
  truncateSettings: "Content truncation",
  truncateContent: "Truncate long content?",
  truncateContentDesc:
    "When using LLM, whether to truncate if the content exceeds the maximum word count",
  maxContentLength: "Max content length after truncation",
  maxContentLengthDesc: "Set the maximum token limit for the content",
  truncateMethod: "Truncation method",
  truncateMethodDesc: "Choose how to handle content that exceeds the limit",
  head_only: "Extract only the beginning",
  head_tail: "Extract the beginning and the end",
  heading: "Extract the heading and the text below it",
  taggingOptions: "Tags",
  taggingOptionsDesc: "Automatically generating tags",
  extractTags: "Extract tags",
  extractTagsDesc:
    "Extract tags that appear more than twice from all notes and fill them in the candidate box",
  extract: "Extract",
  tagList: "Tag list",
  tagListDesc: "Optional tag list, separated by line breaks",
  metaTagsPrompt: "Tags Generation Prompt",
  metaTagsPromptDesc:
    "The prompt for generating tags, where you can set the language, capitalization, etc.",
  defaultTagsPrompt:
    "Please extract up to three tags based on the following article content, and in the same language as the content.",
  tagsFieldName: "Tags field name",
  tagsFieldNameDesc:
    "Field name used for automatically generating tags (default: tags)",
  simplifyTagsConfirm:
    "The current tag list contains {count} tokens, do you want to use AI to simplify it?",
  simplifyTagsPrompt:
    "Please simplify the following tag list to within {count} most important tags, keeping the original format and not returning any other content. The tag list is as follows:",
  description: "Description",
  descriptionPrompt: "Prompt",
  descriptionPromptDesc: "Prompt for generating descriptions",
  defaultSummaryPrompt:
    "Summarize the core content of the article directly without using phrases like 'this article.' The summary should be no more than 50 words, and in the same language as the content.",
  descriptionFieldName: "Description field name",
  descriptionFieldNameDesc:
    "Field name used for automatically generating descriptions (default: description)",
  title: "Title",
  enableTitle: "Enable auto title generation",
  enableTitleDesc: "Enable to automatically generate document titles",
  titlePrompt: "Title prompt",
  titlePromptDesc: "Prompt for generating titles",
  defaultTitlePrompt:
    "Please generate a concise and clear title for this document, no more than 10 words, and do not use quotes.",
  titleFieldName: "Title field name",
  titleFieldNameDesc:
    "Field name used for automatically generating titles (default: title)",
  editTime: "Edit time",
  enableEditTime: "Enable auto update edit time",
  enableEditTimeDesc:
    "Enable to automatically update the edit time of the document",
  editTimeFormat: "Edit time format",
  editTimeFormatDesc: "Set the format of the edit time",
  updateTimeFieldName: "Update time field name",
  updateTimeFieldNameDesc:
    "Field name used for automatically updating the update time (default: updated)",
  createTimeFieldName: "Create time field name",
  createTimeFieldNameDesc:
    "Field name used for automatically updating the create time (default: created)",
  customMetadata: "Custom metadata",
  customMetadataDesc: "Add custom metadata fields, e.g.: author=Author Name",
  addField: "Add field",
  fieldKey: "Field name",
  fieldValue: "Field value",
  categoryOptions: "Category",
  enableCategory: "Enable auto category",
  enableCategoryDesc: "Enable to automatically select category for documents",
  categoryFieldName: "Category field name",
  categoryFieldNameDesc:
    "Field name used for automatically generating category (default: category)",
  categoryList: "Category list",
  categoryListDesc: "Optional category list, separated by line breaks",
  metaCategoryPrompt: "Category prompt",
  metaCategoryPromptDesc: "Prompt for generating category",
  defaultCategoryPrompt: "Please select a suitable category for this document",
  categoryUnknown: "Unknown",
  defaultCategories:
    '["Travel", "Shopping", "Mood", "Book Review", "Tech & Knowledge", "Entertainment", "Papers to Read", "Ideas & Inspiration", "Todo", "Methodology", "Work Thoughts", "Investment", "Books to Read", "Personal Info", "Accounting", "Tasks", "Health", "Excerpts", "Daily Life", "Worldview", "Food"]',
  donate: "Donate",
  donateDesc: "Thank you for your support",
  supportThisPlugin: "Support this plugin",
  supportThisPluginDesc:
    "If you find this plugin helpful, consider buying me a coffee!",
  bugMeACoffee: "Buy me a coffee",
  exmemoAdjustMeta: "Generate meta data",
  exmemoSelectFolder: "Select a suitable folder for the current file",
  exmemoInsertMd: "Insert the selected text into the best position",
  exmemoLLMAssistant: "AI Editor",
  exmemoGenerateNext: "Generate next sentence",
  llmAssistantSetting: "AI Editor",
  llmAssistantSettingDesc:
    "Supports LLM dialogue, content editing, and continuation",
  llmAssistantDialogEdit: "Is the prompt editable?",
  llmAssistantDialogEditDesc:
    "Whether to allow editing of previously saved prompts. If allowed, please trigger the dialog through the button",
  allFolders: "All folders",
  noFolders: "No folders found",
  tooManyFolders_1: " has ",
  tooManyFolders_2: " subdirs, which is quite a lot. Continue?",
  searchDesc: "Filter folders by keyword",
  pleaseSelectFolder: "Please select a folder to start migrating",
  folderNotFound: "Folder not found: ",
  migrationSuccess: "Migration successful",
  folderSelectionSetting: "Folder selection",
  folderSelectionSettingDesc:
    "Select a suitable folder for the current file and migrate it. The selected folder will be used as the target folder for the current file.",
  excludedFolders: "Excluded folders",
  excludedFoldersDesc:
    "Select a suitable folder for the current file and migrate it. List the excluded target folders, separated by line breaks",
  insertContent: "Content to be inserted",
  foundFilesNeedProcess:
    "A total of {total} files are included in the subdirectory, of which {count} files need to extract information. ",
  processCancelled: "Processing cancelled",
  processComplete: "Processing complete for {count} files",
  cancel: "Cancel",
  ok: "OK",
  continue: "Continue",
  processing: "Processing",
  estimatedTokens:
    "Estimated consumption {tokens} token, do you want to extract information?",
  skip: "Skip LLM",
  createIndex: "ExMemo generate dir index",
  fileList: "File list",
  fileDetail: "File detail",
  noDescription: "No description",
  moc: "MOC",
  processingFiles: "Processing files",
  generatingIndex: "Generating index",
  processCompleteWithIndex:
    "Completed processing {count} files and generated {dirs} directory indices",
  indexFileSetting: "Index file",
  indexFileSettingDesc:
    "Generate index file for the directory and summarize the directory content",
  defaultIndexString: "Index file name",
  defaultIndexStringDesc:
    "Default string at the beginning of the index file name",
  indexExcludeFile: "Excluded files",
  indexExcludeFileDesc:
    "Specify files that do not need to generate meta information. Files containing specified keywords will be excluded. Use * as a wildcard and separate with commas.",
  indexExcludeDir: "Excluded directories",
  indexExcludeDirDesc:
    "Specify directories that do not need to be indexed. Directories containing specified keywords will be excluded. Use * as a wildcard and separate with commas.",
  foundDirsNeedIndex: "{dirs} directories that need to extract information.",
  promptManager: "Prompt Manager",
  addPrompt: "Add Prompt",
  addNewPrompt: "Add New Prompt",
  enterPrompt: "Enter prompt",
  editPrompt: "Edit Prompt",
  useCount: "Usage count",
  save: "Save",
  managePrompts: "Manage Prompts",
  managePromptsDesc: "Prompt manager for adding, deleting and editing prompts",
  openPromptManager: "Open Prompt Manager",
  coverImage: "Cover Image",
  enableCover: "Enable Cover Image",
  enableCoverDesc: "Add cover image to your notes",
  coverFieldName: "Cover Field Name",
  coverFieldNameDesc: "Field name used for cover image in frontmatter",
  coverUrl: "Default Cover URL",
  coverUrlDesc: "Default cover image URL to use when no image is found",
  useFirstImage: "Use First Image",
  useFirstImageDesc:
    "Automatically use the first image in the article as cover",
};
var es = {
  confirm: "\u786E\u8BA4",
  yes: "\u662F",
  no: "\u5426",
  llmLoading: "LLM \u601D\u8003\u4E2D...",
  noResult: "LLM \u65E0\u7ED3\u679C",
  pleaseOpenFile: "\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u4EF6",
  llmError: "LLM \u9519\u8BEF",
  inputPrompt: "\u8BF7\u8F93\u5165\u63D0\u793A\u8BCD",
  chatButton: "\u5BF9\u8BDD",
  pleaseSelectText: "\u8BF7\u5148\u9009\u62E9\u6587\u672C",
  currentFileNotMarkdown:
    "\u5F53\u524D\u6587\u4EF6\u4E0D\u662F markdown \u6587\u4EF6",
  fileAlreadyContainsTagsAndDescription:
    "\u6587\u4EF6\u5DF2\u7ECF\u5305\u542B\u6807\u7B7E\u548C\u63CF\u8FF0",
  parseError: "\u89E3\u6790\u9519\u8BEF",
  metaUpdated: "\u5143\u6570\u636E\u5DF2\u66F4\u65B0",
  llmSettings: "LLM",
  apiKey: "API Key",
  baseUrl: "Base URL",
  modelName: "\u6A21\u578B\u540D\u79F0",
  metaSetting: "\u751F\u6210\u5143\u6570\u636E",
  metaSettingDesc:
    "\u81EA\u52A8\u751F\u6210\u6587\u4EF6\u7684\u5143\u6570\u636E",
  metaUpdateSetting: "\u66F4\u65B0\u5143\u6570\u636E",
  updateMetaOptions: "\u66F4\u65B0\u9009\u9879",
  updateMetaOptionsDesc:
    "\u5982\u679C\u5143\u6570\u636E\u5DF2\u7ECF\u5B58\u5728\uFF0C\u662F\u5426\u91CD\u65B0\u751F\u6210",
  updateForce: "\u5F3A\u5236\u66F4\u65B0\u5DF2\u5B58\u5728\u9879",
  updateNoLLM: "\u53EA\u66F4\u65B0\u4E0D\u7528LLM\u7684\u9879",
  truncateSettings: "\u5185\u5BB9\u622A\u65AD",
  truncateContent: "\u5185\u5BB9\u592A\u957F\u662F\u5426\u622A\u65AD",
  truncateContentDesc:
    "\u4F7F\u7528LLM\u65F6\uFF0C\u5982\u679C\u5185\u5BB9\u8D85\u8FC7\u6700\u5927\u5B57\u6570\uFF0C\u662F\u5426\u622A\u65AD",
  maxContentLength: "\u622A\u65AD\u540E\u6700\u5927\u5185\u5BB9\u957F\u5EA6",
  maxContentLengthDesc:
    "\u8BBE\u7F6E\u5185\u5BB9\u7684\u6700\u5927 token \u9650\u5236",
  truncateMethod: "\u622A\u65AD\u65B9\u5F0F",
  truncateMethodDesc:
    "\u9009\u62E9\u5185\u5BB9\u8D85\u8FC7\u9650\u5236\u65F6\u7684\u5904\u7406\u65B9\u5F0F",
  head_only: "\u4EC5\u63D0\u53D6\u5F00\u5934\u90E8\u5206",
  head_tail: "\u63D0\u53D6\u5F00\u5934\u548C\u7ED3\u5C3E\u90E8\u5206",
  heading: "\u63D0\u53D6\u6807\u9898\u53CA\u5176\u4E0B\u65B9\u7684\u6587\u5B57",
  taggingOptions: "\u6807\u7B7E",
  taggingOptionsDesc: "\u81EA\u52A8\u751F\u6210\u6807\u7B7E",
  extractTags: "\u63D0\u53D6\u6807\u7B7E",
  extractTagsDesc:
    "\u4ECE\u6240\u6709\u7B14\u8BB0\u4E2D\u63D0\u53D6\u51FA\u73B0\u8D85\u8FC7\u4E24\u6B21\u7684\u6807\u7B7E",
  extract: "\u63D0\u53D6",
  tagList: "\u6807\u7B7E\u5217\u8868",
  tagListDesc:
    "\u53EF\u9009\u6807\u7B7E\u5217\u8868\uFF0C\u4F7F\u7528\u56DE\u8F66\u5206\u9694",
  metaTagsPrompt: "\u6807\u7B7E\u751F\u6210\u63D0\u793A\u8BCD",
  metaTagsPromptDesc:
    "\u7528\u4E8E\u751F\u6210\u6807\u7B7E\u7684\u63D0\u793A\u8BCD\uFF0C\u53EF\u5728\u6B64\u8BBE\u7F6E\u8BED\u8A00\u3001\u5927\u5C0F\u5199\u7B49",
  defaultTagsPrompt:
    "\u8BF7\u63D0\u53D6\u8FD9\u7BC7\u6587\u7AE0\u4E2D\u6700\u5408\u9002\u7684\u4E0D\u8D85\u8FC7\u4E09\u4E2A\u6807\u7B7E\uFF0C\u5E76\u4F7F\u7528\u4E0E\u5185\u5BB9\u76F8\u540C\u7684\u8BED\u8A00\u3002",
  tagsFieldName: "\u6807\u7B7E\u5B57\u6BB5\u540D",
  tagsFieldNameDesc:
    "\u81EA\u52A8\u751F\u6210\u6807\u7B7E\u4F7F\u7528\u7684\u5B57\u6BB5\u540D (\u9ED8\u8BA4: tags)",
  simplifyTagsConfirm:
    "\u5F53\u524D\u6807\u7B7E\u5217\u8868\u5305\u542B {count} \u4E2Atokens\uFF0C\u662F\u5426\u9700\u8981\u4F7F\u7528AI\u81EA\u52A8\u7CBE\u7B80\uFF1F",
  simplifyTagsPrompt:
    "\u8BF7\u5C06\u4EE5\u4E0B\u6807\u7B7E\u5217\u8868\u7CBE\u7B80\u5230{count}\u4E2A\u4EE5\u5185\u6700\u91CD\u8981\u7684\u6807\u7B7E\uFF0C\u4FDD\u6301\u539F\u6709\u683C\u5F0F\uFF0C\u4E0D\u8FD4\u56DE\u5176\u5B83\u5185\u5BB9\uFF0C\u6807\u7B7E\u5217\u8868\u5982\u4E0B\uFF1A",
  description: "\u63CF\u8FF0",
  descriptionPrompt: "\u63CF\u8FF0\u63D0\u793A\u8BCD",
  descriptionPromptDesc:
    "\u7528\u4E8E\u751F\u6210\u63CF\u8FF0\u7684\u63D0\u793A\u8BCD",
  defaultSummaryPrompt:
    "\u76F4\u63A5\u603B\u7ED3\u6587\u7AE0\u7684\u6838\u5FC3\u5185\u5BB9\uFF0C\u4E0D\u8981\u4F7F\u7528'\u8FD9\u7BC7\u6587\u7AE0'\u8FD9\u6837\u7684\u77ED\u8BED\uFF0C\u4E0D\u8D85\u8FC750\u4E2A\u5B57\uFF0C\u4E14\u4E0E\u5185\u5BB9\u4F7F\u7528\u76F8\u540C\u8BED\u8A00\u56DE\u7B54\u3002",
  descriptionFieldName: "\u63CF\u8FF0\u5B57\u6BB5\u540D",
  descriptionFieldNameDesc:
    "\u81EA\u52A8\u751F\u6210\u63CF\u8FF0\u4F7F\u7528\u7684\u5B57\u6BB5\u540D (\u9ED8\u8BA4: description)",
  title: "\u6807\u9898",
  enableTitle: "\u542F\u7528\u81EA\u52A8\u751F\u6210\u6807\u9898",
  enableTitleDesc:
    "\u542F\u7528\u540E\u5C06\u81EA\u52A8\u751F\u6210\u6587\u6863\u6807\u9898",
  titlePrompt: "\u6807\u9898\u751F\u6210\u63D0\u793A\u8BCD",
  titlePromptDesc:
    "\u7528\u4E8E\u751F\u6210\u6807\u9898\u7684\u63D0\u793A\u8BCD",
  defaultTitlePrompt:
    "\u8BF7\u4E3A\u8FD9\u7BC7\u6587\u6863\u751F\u6210\u4E00\u4E2A\u7B80\u6D01\u660E\u4E86\u7684\u6807\u9898\uFF0C\u4E0D\u8D85\u8FC710\u4E2A\u5B57\uFF0C\u4E0D\u8981\u4F7F\u7528\u5F15\u53F7\u3002",
  titleFieldName: "\u6807\u9898\u5B57\u6BB5\u540D",
  titleFieldNameDesc:
    "\u81EA\u52A8\u751F\u6210\u6807\u9898\u4F7F\u7528\u7684\u5B57\u6BB5\u540D (\u9ED8\u8BA4: title)",
  editTime: "\u7F16\u8F91\u65F6\u95F4",
  enableEditTime:
    "\u542F\u7528\u81EA\u52A8\u66F4\u65B0\u7F16\u8F91\u65F6\u95F4",
  enableEditTimeDesc:
    "\u542F\u7528\u540E\u5C06\u81EA\u52A8\u66F4\u65B0\u6587\u6863\u7684\u7F16\u8F91\u65F6\u95F4",
  editTimeFormat: "\u65F6\u95F4\u683C\u5F0F",
  editTimeFormatDesc:
    "\u7F16\u8F91\u65F6\u95F4\u7684\u683C\u5F0F\uFF0C\u4F7F\u7528 moment.js \u683C\u5F0F",
  updateTimeFieldName: "\u66F4\u65B0\u65F6\u95F4\u5B57\u6BB5\u540D",
  updateTimeFieldNameDesc:
    "\u81EA\u52A8\u66F4\u65B0\u7F16\u8F91\u65F6\u95F4\u4F7F\u7528\u7684\u5B57\u6BB5\u540D (\u9ED8\u8BA4: updated)",
  createTimeFieldName: "\u521B\u5EFA\u65F6\u95F4\u5B57\u6BB5\u540D",
  createTimeFieldNameDesc:
    "\u81EA\u52A8\u751F\u6210\u521B\u5EFA\u65F6\u95F4\u4F7F\u7528\u7684\u5B57\u6BB5\u540D (\u9ED8\u8BA4: created)",
  customMetadata: "\u81EA\u5B9A\u4E49\u5143\u6570\u636E",
  customMetadataDesc:
    "\u6DFB\u52A0\u81EA\u5B9A\u4E49\u7684\u5143\u6570\u636E\u5B57\u6BB5\uFF0C\u5982\uFF1Aauthor=\u4F5C\u8005\u540D",
  addField: "\u6DFB\u52A0\u5B57\u6BB5",
  fieldKey: "\u5B57\u6BB5\u540D",
  fieldValue: "\u5B57\u6BB5\u503C",
  categoryOptions: "\u7C7B\u522B",
  enableCategory: "\u542F\u7528\u81EA\u52A8\u5206\u7C7B",
  enableCategoryDesc:
    "\u542F\u7528\u540E\u5C06\u81EA\u52A8\u4E3A\u6587\u6863\u9009\u62E9\u7C7B\u522B",
  categoryFieldName: "\u7C7B\u522B\u5B57\u6BB5\u540D",
  categoryFieldNameDesc:
    "\u81EA\u52A8\u751F\u6210\u7C7B\u522B\u4F7F\u7528\u7684\u5B57\u6BB5\u540D (\u9ED8\u8BA4: category)",
  categoryList: "\u7C7B\u522B\u5217\u8868",
  categoryListDesc:
    "\u53EF\u9009\u7C7B\u522B\u5217\u8868\uFF0C\u4F7F\u7528\u56DE\u8F66\u5206\u9694",
  metaCategoryPrompt: "\u7C7B\u522B\u751F\u6210\u63D0\u793A\u8BCD",
  metaCategoryPromptDesc:
    "\u7528\u4E8E\u751F\u6210\u7C7B\u522B\u7684\u63D0\u793A\u8BCD",
  defaultCategoryPrompt:
    "\u8BF7\u4E3A\u8FD9\u7BC7\u6587\u6863\u9009\u62E9\u4E00\u4E2A\u5408\u9002\u7684\u7C7B\u522B",
  categoryUnknown: "\u672A\u5206\u7C7B",
  defaultCategories:
    '["\u65C5\u884C", "\u8D2D\u7269", "\u5FC3\u60C5", "\u8BFB\u540E\u611F", "\u77E5\u8BC6\u79D1\u6280", "\u5A31\u4E50", "\u5F85\u8BFB\u8BBA\u6587", "\u7075\u611F\u521B\u610F", "\u5F85\u529E\u4E8B\u9879", "\u65B9\u6CD5\u8BBA", "\u5DE5\u4F5C\u601D\u8003", "\u6295\u8D44", "\u5F85\u8BFB\u4E66", "\u4E2A\u4EBA\u4FE1\u606F", "\u8BB0\u5E10", "\u5F85\u505A", "\u5065\u5EB7", "\u6458\u5F55", "\u65E5\u5E38\u7410\u4E8B", "\u4E16\u754C\u89C2", "\u7F8E\u98DF"]',
  donate: "\u6350\u8D60",
  donateDesc: "\u611F\u8C22\u60A8\u7684\u652F\u6301",
  supportThisPlugin: "\u652F\u6301\u6B64\u63D2\u4EF6",
  supportThisPluginDesc:
    "\u5982\u679C\u60A8\u559C\u6B22\u8FD9\u4E2A\u63D2\u4EF6\uFF0C\u53EF\u4EE5\u8BF7\u6211\u559D\u676F\u5496\u5561",
  bugMeACoffee: "\u8BF7\u6211\u559D\u676F\u5496\u5561",
  exmemoAdjustMeta: "\u751F\u6210\u5143\u6570\u636E",
  exmemoSelectFolder:
    "\u4E3A\u5F53\u524D\u6587\u4EF6\u9009\u62E9\u5408\u9002\u7684\u76EE\u5F55",
  exmemoInsertMd:
    "\u5C06\u9009\u4E2D\u7684\u6587\u672C\u63D2\u5165\u5230 markdown \u5408\u9002\u4F4D\u7F6E",
  exmemoLLMAssistant: "\u667A\u80FD\u7F16\u8F91",
  exmemoGenerateNext: "\u7EED\u5199\u4E0B\u4E00\u53E5",
  llmAssistantSetting: "\u667A\u80FD\u7F16\u8F91",
  llmAssistantSettingDesc:
    "\u652F\u6301 LLM \u5BF9\u8BDD\u3001\u5185\u5BB9\u7F16\u8F91\u548C\u7EED\u5199",
  llmAssistantDialogEdit: "\u63D0\u793A\u8BCD\u662F\u5426\u53EF\u7F16\u8F91",
  llmAssistantDialogEditDesc:
    "\u662F\u5426\u5141\u8BB8\u7F16\u8F91\u4E4B\u524D\u4FDD\u5B58\u7684\u63D0\u793A\u8BCD\uFF1B\u5982\u679C\u5141\u8BB8\uFF0C\u5219\u9700\u8981\u901A\u8FC7\u6309\u94AE\u6765\u89E6\u53D1\u5BF9\u8BDD",
  allFolders: "\u5168\u90E8\u76EE\u5F55",
  noFolders: "\u6CA1\u6709\u627E\u5230\u76EE\u5F55",
  tooManyFolders_1: "\u6709",
  tooManyFolders_2:
    "\u4E2A\u5F85\u9009\u5B50\u76EE\u5F55\uFF0C\u6570\u91CF\u8F83\u591A\uFF0C\u662F\u5426\u7EE7\u7EED\uFF1F",
  searchDesc: "\u901A\u8FC7\u5173\u952E\u5B57\u8FC7\u6EE4\u76EE\u5F55",
  pleaseSelectFolder:
    "\u8BF7\u9009\u62E9\u4E00\u4E2A\u76EE\u5F55\u5F00\u59CB\u8FC1\u79FB",
  folderNotFound: "\u672A\u627E\u5230\u76EE\u5F55\uFF1A",
  migrationSuccess: "\u8FC1\u79FB\u6210\u529F",
  folderSelectionSetting: "\u76EE\u5F55\u9009\u62E9",
  folderSelectionSettingDesc:
    "\u4E3A\u5F53\u524D\u6587\u4EF6\u9009\u62E9\u5408\u9002\u7684\u76EE\u5F55\uFF0C\u5E76\u8FC1\u79FB",
  excludedFolders: "\u6392\u9664\u76EE\u5F55",
  excludedFoldersDesc:
    "\u5217\u51FA\u6392\u9664\u7684\u76EE\u6807\u76EE\u5F55\uFF0C\u76EE\u5F55\u4E4B\u95F4\u7528\u56DE\u8F66\u5206\u9694",
  insertContent: "\u5F85\u63D2\u5165\u5185\u5BB9",
  foundFilesNeedProcess:
    "\u5B50\u76EE\u5F55\u4E2D\u5171\u7EB3\u5165 {total} \u4E2A\u6587\u4EF6\uFF0C\u5176\u4E2D {count} \u4E2A\u6587\u4EF6\u9700\u8981\u63D0\u53D6\u4FE1\u606F\u3002",
  processCancelled: "\u5904\u7406\u5DF2\u53D6\u6D88",
  processComplete: "\u5DF2\u5B8C\u6210\u5904\u7406 {count} \u4E2A\u6587\u4EF6",
  cancel: "\u53D6\u6D88",
  continue: "\u7EE7\u7EED",
  processing: "\u5904\u7406\u4E2D",
  estimatedTokens:
    "\u9884\u8BA1\u6D88\u8017 {tokens} token\uFF0C\u662F\u5426\u7528\u6A21\u578B\u63D0\u53D6\u4FE1\u606F\uFF1F",
  skip: "\u8DF3\u8FC7 LLM \u63D0\u53D6",
  createIndex: "ExMemo\u751F\u6210\u76EE\u5F55\u7D22\u5F15",
  fileList: "\u6587\u4EF6\u5217\u8868",
  fileDetail: "\u6587\u4EF6\u8BE6\u60C5",
  noDescription: "\u6682\u65E0",
  moc: "\u76EE\u5F55",
  processingFiles: "\u5904\u7406\u6587\u4EF6",
  generatingIndex: "\u751F\u6210\u7D22\u5F15",
  processCompleteWithIndex:
    "\u5DF2\u5B8C\u6210\u5904\u7406 {count} \u4E2A\u6587\u4EF6\u5E76\u751F\u6210 {dirs} \u4E2A\u76EE\u5F55\u7D22\u5F15",
  indexFileSetting: "\u751F\u6210\u7D22\u5F15\u6587\u4EF6",
  indexFileSettingDesc:
    "\u4E3A\u76EE\u5F55\u751F\u6210\u7D22\u5F15\u6587\u4EF6\uFF0C\u5E76\u603B\u7ED3\u76EE\u5F55\u5185\u5BB9",
  defaultIndexString: "\u7D22\u5F15\u6587\u4EF6\u540D",
  defaultIndexStringDesc:
    "\u7D22\u5F15\u6587\u4EF6\u540D\u5F00\u5934\u7684\u9ED8\u8BA4\u5B57\u7B26\u4E32",
  indexExcludeFile: "\u6392\u9664\u7684\u6587\u4EF6",
  indexExcludeFileDesc:
    "\u6307\u5B9A\u4E0D\u9700\u8981\u751F\u6210Meta\u4FE1\u606F\u7684\u6587\u4EF6\uFF0C\u5305\u542B\u6307\u5B9A\u5173\u952E\u5B57\u7684\u6587\u4EF6\u5C06\u88AB\u6392\u9664\u3002\u4F7F\u7528 * \u4F5C\u4E3A\u901A\u914D\u7B26\uFF0C\u5E76\u7528\u9017\u53F7\u5206\u9694\u3002",
  indexExcludeDir: "\u6392\u9664\u7684\u76EE\u5F55",
  indexExcludeDirDesc:
    "\u6307\u5B9A\u4E0D\u9700\u8981\u5EFA\u7ACB\u7D22\u5F15\u7684\u76EE\u5F55\uFF0C\u5305\u542B\u6307\u5B9A\u5173\u952E\u5B57\u7684\u76EE\u5F55\u5C06\u88AB\u6392\u9664\u3002\u4F7F\u7528 * \u4F5C\u4E3A\u901A\u914D\u7B26\uFF0C\u5E76\u7528\u9017\u53F7\u5206\u9694\u3002",
  foundDirsNeedIndex:
    "{dirs} \u4E2A\u76EE\u5F55\u9700\u8981\u63D0\u53D6\u4FE1\u606F\u3002",
  promptManager: "\u63D0\u793A\u8BCD\u7BA1\u7406",
  addPrompt: "\u6DFB\u52A0\u63D0\u793A\u8BCD",
  addNewPrompt: "\u6DFB\u52A0\u65B0\u63D0\u793A\u8BCD",
  enterPrompt: "\u8BF7\u8F93\u5165\u63D0\u793A\u8BCD",
  editPrompt: "\u7F16\u8F91\u63D0\u793A\u8BCD",
  useCount: "\u4F7F\u7528\u6B21\u6570",
  save: "\u4FDD\u5B58",
  managePrompts: "\u7BA1\u7406\u63D0\u793A\u8BCD",
  managePromptsDesc:
    "\u63D0\u793A\u8BCD\u7BA1\u7406\u5668\uFF0C\u652F\u6301\u6DFB\u52A0\u3001\u5220\u9664\u548C\u7F16\u8F91\u63D0\u793A\u8BCD",
  openPromptManager: "\u6253\u5F00\u63D0\u793A\u8BCD\u7BA1\u7406\u5668",
  coverImage: "\u5C01\u9762\u56FE",
  enableCover: "\u542F\u7528\u5C01\u9762\u56FE",
  enableCoverDesc: "\u4E3A\u7B14\u8BB0\u6DFB\u52A0\u5C01\u9762\u56FE",
  coverFieldName: "\u5C01\u9762\u56FE\u5B57\u6BB5\u540D",
  coverFieldNameDesc:
    "\u5728frontmatter\u4E2D\u4F7F\u7528\u7684\u5C01\u9762\u56FE\u5B57\u6BB5\u540D\u79F0",
  coverUrl: "\u9ED8\u8BA4\u5C01\u9762\u56FEURL",
  coverUrlDesc:
    "\u5F53\u672A\u627E\u5230\u56FE\u7247\u65F6\u4F7F\u7528\u7684\u9ED8\u8BA4\u5C01\u9762\u56FE\u5730\u5740",
  useFirstImage: "\u4F7F\u7528\u7B2C\u4E00\u5F20\u56FE\u7247",
  useFirstImageDesc:
    "\u81EA\u52A8\u4F7F\u7528\u6587\u7AE0\u4E2D\u7684\u7B2C\u4E00\u5F20\u56FE\u7247\u4F5C\u4E3A\u5C01\u9762\u56FE",
};
var pa = { en: tr, "zh-cn": es },
  ts = pa[ns.moment.locale()];
function c(r) {
  return (ts && ts[r]) || tr[r];
}
var rs = {
  llmToken: "sk-",
  llmBaseUrl: "https://api.openai.com/v1",
  llmModelName: "gpt-4o",
  llmPrompts: {},
  llmDialogEdit: !1,
  tags: [],
  metaIsTruncate: !0,
  metaMaxTokens: 1e3,
  metaTruncateMethod: "head_only",
  metaUpdateMethod: "no-llm",
  metaDescription: c("defaultSummaryPrompt"),
  metaTitleEnabled: !0,
  metaTitlePrompt: c("defaultTitlePrompt"),
  metaEditTimeEnabled: !0,
  metaEditTimeFormat: "YYYY-MM-DD HH:mm:ss",
  selectExcludedFolders: [],
  metaTagsFieldName: "tags",
  metaDescriptionFieldName: "description",
  metaTitleFieldName: "title",
  metaUpdatedFieldName: "updated",
  metaCreatedFieldName: "created",
  metaTagsPrompt: c("defaultTagsPrompt"),
  customMetadata: [],
  metaCategoryFieldName: "category",
  categories: JSON.parse(c("defaultCategories")),
  metaCategoryPrompt: c("defaultCategoryPrompt"),
  metaCategoryEnabled: !0,
  defaultIndexString: "index_",
  indexExcludeFile: "",
  indexExcludeDir: "",
  metaCoverEnabled: !1,
  metaCoverFieldName: "cover",
  metaCoverUrl: "",
  metaCoverUseFirst: !1,
};
var T = require("obsidian");
var xe = require("obsidian");
function nr(r, e, t) {
  var o, l;
  let n = r[e],
    s = r[t],
    a = (o = n.priority) != null ? o : Number.MAX_SAFE_INTEGER,
    i = (l = s.priority) != null ? l : Number.MAX_SAFE_INTEGER;
  return i !== a
    ? a - i
    : s.count !== n.count
      ? s.count - n.count
      : s.lastAccess - n.lastAccess;
}
async function rr(r, e, t = 0) {
  let n = r.settings.llmPrompts,
    s = Date.now();
  return (
    n[e]
      ? ((n[e].count += 1), (n[e].lastAccess = s))
      : (n[e] = { count: t, lastAccess: s, priority: null }),
    (r.settings.llmPrompts = n),
    await r.saveSettings(),
    n[e]
  );
}
var yn = class extends xe.Modal {
  constructor(t, n) {
    super(t);
    this.draggedItem = null;
    (this.plugin = n), (this.prompts = n.settings.llmPrompts || {});
  }
  onOpen() {
    let { contentEl: t } = this;
    t.empty(),
      t.createEl("h3", { text: c("promptManager") }),
      new xe.Setting(t).addButton((s) =>
        s
          .setButtonText(c("addPrompt"))
          .setCta()
          .onClick(() => this.showAddPromptDialog()),
      );
    let n = t.createEl("div", { cls: "prompts-container" });
    this.renderPromptList(n);
  }
  renderPromptList(t) {
    if (!t) return;
    t.empty(),
      Object.entries(this.prompts)
        .sort(([s], [a]) => nr(this.prompts, s, a))
        .forEach(([s, a]) => {
          let i = t.createEl("div", {
            cls: "prompt-item",
            attr: { draggable: "true" },
          });
          i.addEventListener("dragstart", (o) => {
            (this.draggedItem = i), i.addClass("dragging");
          }),
            i.addEventListener("dragend", async () => {
              i.removeClass("dragging"),
                await this.updatePriorities(),
                (this.draggedItem = null);
            }),
            i.addEventListener("dragover", (o) => {
              if (
                (o.preventDefault(), this.draggedItem && this.draggedItem !== i)
              ) {
                let l = i.getBoundingClientRect(),
                  d = (l.top + l.bottom) / 2;
                o.clientY < d
                  ? i.before(this.draggedItem)
                  : i.after(this.draggedItem);
              }
            }),
            new xe.Setting(i)
              .setName(s)
              .setDesc(`${c("useCount")}: ${a.count}`)
              .addButton((o) =>
                o.setIcon("pencil").onClick(() => this.showEditPromptDialog(s)),
              )
              .addButton((o) =>
                o.setIcon("trash").onClick(() => this.deletePrompt(s)),
              );
        });
  }
  async updatePriorities() {
    let t = this.contentEl.querySelector(".prompts-container"),
      n = t == null ? void 0 : t.querySelectorAll(".prompt-item");
    if (!n || !this.draggedItem) return;
    let s = -1;
    n.forEach((a, i) => {
      a === this.draggedItem && (s = i);
    }),
      s !== -1 &&
        (n.forEach((a, i) => {
          var l;
          let o =
            (l = a.querySelector(".setting-item-name")) == null
              ? void 0
              : l.textContent;
          o &&
            this.prompts[o] &&
            (i <= s ||
              ("priority" in this.prompts[o] &&
                this.prompts[o].priority !== null)) &&
            (this.prompts[o].priority = i);
        }),
        await this.savePrompts());
  }
  async showAddPromptDialog() {
    let t = new xe.Modal(this.app);
    t.titleEl.setText(c("addNewPrompt"));
    let n = t.contentEl.createEl("textarea");
    (n.placeholder = c("enterPrompt")),
      (n.style.width = "100%"),
      (n.style.height = "100px"),
      new xe.Setting(t.contentEl).addButton((s) =>
        s
          .setButtonText(c("save"))
          .setCta()
          .onClick(async () => {
            let a = n.value.trim();
            a &&
              (await rr(this.plugin, a),
              (this.prompts = this.plugin.settings.llmPrompts),
              this.renderPromptList(
                this.contentEl.querySelector(".prompts-container"),
              ),
              t.close());
          }),
      ),
      t.open();
  }
  async showEditPromptDialog(t) {
    let n = new xe.Modal(this.app);
    n.titleEl.setText(c("editPrompt"));
    let s = n.contentEl.createEl("textarea");
    (s.value = t),
      (s.style.width = "100%"),
      (s.style.height = "100px"),
      new xe.Setting(n.contentEl).addButton((a) =>
        a
          .setButtonText(c("save"))
          .setCta()
          .onClick(async () => {
            let i = s.value.trim();
            i &&
              i !== t &&
              ((this.prompts[i] = this.prompts[t]),
              delete this.prompts[t],
              await this.savePrompts(),
              this.renderPromptList(
                this.contentEl.querySelector(".prompts-container"),
              ),
              n.close());
          }),
      ),
      n.open();
  }
  async deletePrompt(t) {
    delete this.prompts[t],
      await this.savePrompts(),
      this.renderPromptList(this.contentEl.querySelector(".prompts-container"));
  }
  async savePrompts() {
    (this.prompts = Object.fromEntries(
      Object.entries(this.prompts).sort(([t, n], [s, a]) => {
        var l, d;
        let i = (l = n.priority) != null ? l : Number.MAX_SAFE_INTEGER,
          o = (d = a.priority) != null ? d : Number.MAX_SAFE_INTEGER;
        return i !== o
          ? i - o
          : n.count !== a.count
            ? a.count - n.count
            : a.lastAccess - n.lastAccess;
      }),
    )),
      (this.plugin.settings.llmPrompts = this.prompts),
      await this.plugin.saveSettings();
  }
  onClose() {
    let { contentEl: t } = this;
    t.empty();
  }
};
var ge = require("obsidian");
var wn = "RFC3986",
  xn = {
    RFC1738: (r) => String(r).replace(/%20/g, "+"),
    RFC3986: (r) => String(r),
  },
  ss = "RFC1738";
var ga = Array.isArray,
  oe = (() => {
    let r = [];
    for (let e = 0; e < 256; ++e)
      r.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
    return r;
  })();
var sr = 1024,
  as = (r, e, t, n, s) => {
    if (r.length === 0) return r;
    let a = r;
    if (
      (typeof r == "symbol"
        ? (a = Symbol.prototype.toString.call(r))
        : typeof r != "string" && (a = String(r)),
      t === "iso-8859-1")
    )
      return escape(a).replace(/%u[0-9a-f]{4}/gi, function (o) {
        return "%26%23" + parseInt(o.slice(2), 16) + "%3B";
      });
    let i = "";
    for (let o = 0; o < a.length; o += sr) {
      let l = a.length >= sr ? a.slice(o, o + sr) : a,
        d = [];
      for (let f = 0; f < l.length; ++f) {
        let m = l.charCodeAt(f);
        if (
          m === 45 ||
          m === 46 ||
          m === 95 ||
          m === 126 ||
          (m >= 48 && m <= 57) ||
          (m >= 65 && m <= 90) ||
          (m >= 97 && m <= 122) ||
          (s === ss && (m === 40 || m === 41))
        ) {
          d[d.length] = l.charAt(f);
          continue;
        }
        if (m < 128) {
          d[d.length] = oe[m];
          continue;
        }
        if (m < 2048) {
          d[d.length] = oe[192 | (m >> 6)] + oe[128 | (m & 63)];
          continue;
        }
        if (m < 55296 || m >= 57344) {
          d[d.length] =
            oe[224 | (m >> 12)] +
            oe[128 | ((m >> 6) & 63)] +
            oe[128 | (m & 63)];
          continue;
        }
        (f += 1),
          (m = 65536 + (((m & 1023) << 10) | (l.charCodeAt(f) & 1023))),
          (d[d.length] =
            oe[240 | (m >> 18)] +
            oe[128 | ((m >> 12) & 63)] +
            oe[128 | ((m >> 6) & 63)] +
            oe[128 | (m & 63)]);
      }
      i += d.join("");
    }
    return i;
  };
function is(r) {
  return !r || typeof r != "object"
    ? !1
    : !!(r.constructor && r.constructor.isBuffer && r.constructor.isBuffer(r));
}
function ar(r, e) {
  if (ga(r)) {
    let t = [];
    for (let n = 0; n < r.length; n += 1) t.push(e(r[n]));
    return t;
  }
  return e(r);
}
var ya = Object.prototype.hasOwnProperty,
  os = {
    brackets(r) {
      return String(r) + "[]";
    },
    comma: "comma",
    indices(r, e) {
      return String(r) + "[" + e + "]";
    },
    repeat(r) {
      return String(r);
    },
  },
  le = Array.isArray,
  wa = Array.prototype.push,
  ls = function (r, e) {
    wa.apply(r, le(e) ? e : [e]);
  },
  xa = Date.prototype.toISOString,
  U = {
    addQueryPrefix: !1,
    allowDots: !1,
    allowEmptyArrays: !1,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encodeDotInKeys: !1,
    encoder: as,
    encodeValuesOnly: !1,
    format: wn,
    formatter: xn[wn],
    indices: !1,
    serializeDate(r) {
      return xa.call(r);
    },
    skipNulls: !1,
    strictNullHandling: !1,
  };
function _a(r) {
  return (
    typeof r == "string" ||
    typeof r == "number" ||
    typeof r == "boolean" ||
    typeof r == "symbol" ||
    typeof r == "bigint"
  );
}
var ir = {};
function cs(r, e, t, n, s, a, i, o, l, d, f, m, y, h, b, x, u, p) {
  let w = r,
    g = p,
    A = 0,
    E = !1;
  for (; (g = g.get(ir)) !== void 0 && !E; ) {
    let M = g.get(r);
    if (((A += 1), typeof M != "undefined")) {
      if (M === A) throw new RangeError("Cyclic object value");
      E = !0;
    }
    typeof g.get(ir) == "undefined" && (A = 0);
  }
  if (
    (typeof d == "function"
      ? (w = d(e, w))
      : w instanceof Date
        ? (w = y == null ? void 0 : y(w))
        : t === "comma" &&
          le(w) &&
          (w = ar(w, function (M) {
            return M instanceof Date ? (y == null ? void 0 : y(M)) : M;
          })),
    w === null)
  ) {
    if (a) return l && !x ? l(e, U.encoder, u, "key", h) : e;
    w = "";
  }
  if (_a(w) || is(w)) {
    if (l) {
      let M = x ? e : l(e, U.encoder, u, "key", h);
      return [
        (b == null ? void 0 : b(M)) +
          "=" +
          (b == null ? void 0 : b(l(w, U.encoder, u, "value", h))),
      ];
    }
    return [
      (b == null ? void 0 : b(e)) + "=" + (b == null ? void 0 : b(String(w))),
    ];
  }
  let I = [];
  if (typeof w == "undefined") return I;
  let R;
  if (t === "comma" && le(w))
    x && l && (w = ar(w, l)),
      (R = [{ value: w.length > 0 ? w.join(",") || null : void 0 }]);
  else if (le(d)) R = d;
  else {
    let M = Object.keys(w);
    R = f ? M.sort(f) : M;
  }
  let D = o ? String(e).replace(/\./g, "%2E") : String(e),
    v = n && le(w) && w.length === 1 ? D + "[]" : D;
  if (s && le(w) && w.length === 0) return v + "[]";
  for (let M = 0; M < R.length; ++M) {
    let $ = R[M],
      N =
        typeof $ == "object" && typeof $.value != "undefined" ? $.value : w[$];
    if (i && N === null) continue;
    let Z = m && o ? $.replace(/\./g, "%2E") : $,
      we = le(w)
        ? typeof t == "function"
          ? t(v, Z)
          : v
        : v + (m ? "." + Z : "[" + Z + "]");
    p.set(r, A);
    let X = new WeakMap();
    X.set(ir, p),
      ls(
        I,
        cs(
          N,
          we,
          t,
          n,
          s,
          a,
          i,
          o,
          t === "comma" && x && le(w) ? null : l,
          d,
          f,
          m,
          y,
          h,
          b,
          x,
          u,
          X,
        ),
      );
  }
  return I;
}
function ba(r = U) {
  if (
    typeof r.allowEmptyArrays != "undefined" &&
    typeof r.allowEmptyArrays != "boolean"
  )
    throw new TypeError(
      "`allowEmptyArrays` option can only be `true` or `false`, when provided",
    );
  if (
    typeof r.encodeDotInKeys != "undefined" &&
    typeof r.encodeDotInKeys != "boolean"
  )
    throw new TypeError(
      "`encodeDotInKeys` option can only be `true` or `false`, when provided",
    );
  if (
    r.encoder !== null &&
    typeof r.encoder != "undefined" &&
    typeof r.encoder != "function"
  )
    throw new TypeError("Encoder has to be a function.");
  let e = r.charset || U.charset;
  if (
    typeof r.charset != "undefined" &&
    r.charset !== "utf-8" &&
    r.charset !== "iso-8859-1"
  )
    throw new TypeError(
      "The charset option must be either utf-8, iso-8859-1, or undefined",
    );
  let t = wn;
  if (typeof r.format != "undefined") {
    if (!ya.call(xn, r.format))
      throw new TypeError("Unknown format option provided.");
    t = r.format;
  }
  let n = xn[t],
    s = U.filter;
  (typeof r.filter == "function" || le(r.filter)) && (s = r.filter);
  let a;
  if (
    (r.arrayFormat && r.arrayFormat in os
      ? (a = r.arrayFormat)
      : "indices" in r
        ? (a = r.indices ? "indices" : "repeat")
        : (a = U.arrayFormat),
    "commaRoundTrip" in r && typeof r.commaRoundTrip != "boolean")
  )
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  let i =
    typeof r.allowDots == "undefined"
      ? r.encodeDotInKeys
        ? !0
        : U.allowDots
      : !!r.allowDots;
  return {
    addQueryPrefix:
      typeof r.addQueryPrefix == "boolean"
        ? r.addQueryPrefix
        : U.addQueryPrefix,
    allowDots: i,
    allowEmptyArrays:
      typeof r.allowEmptyArrays == "boolean"
        ? !!r.allowEmptyArrays
        : U.allowEmptyArrays,
    arrayFormat: a,
    charset: e,
    charsetSentinel:
      typeof r.charsetSentinel == "boolean"
        ? r.charsetSentinel
        : U.charsetSentinel,
    commaRoundTrip: !!r.commaRoundTrip,
    delimiter: typeof r.delimiter == "undefined" ? U.delimiter : r.delimiter,
    encode: typeof r.encode == "boolean" ? r.encode : U.encode,
    encodeDotInKeys:
      typeof r.encodeDotInKeys == "boolean"
        ? r.encodeDotInKeys
        : U.encodeDotInKeys,
    encoder: typeof r.encoder == "function" ? r.encoder : U.encoder,
    encodeValuesOnly:
      typeof r.encodeValuesOnly == "boolean"
        ? r.encodeValuesOnly
        : U.encodeValuesOnly,
    filter: s,
    format: t,
    formatter: n,
    serializeDate:
      typeof r.serializeDate == "function" ? r.serializeDate : U.serializeDate,
    skipNulls: typeof r.skipNulls == "boolean" ? r.skipNulls : U.skipNulls,
    sort: typeof r.sort == "function" ? r.sort : null,
    strictNullHandling:
      typeof r.strictNullHandling == "boolean"
        ? r.strictNullHandling
        : U.strictNullHandling,
  };
}
function or(r, e = {}) {
  let t = r,
    n = ba(e),
    s,
    a;
  typeof n.filter == "function"
    ? ((a = n.filter), (t = a("", t)))
    : le(n.filter) && ((a = n.filter), (s = a));
  let i = [];
  if (typeof t != "object" || t === null) return "";
  let o = os[n.arrayFormat],
    l = o === "comma" && n.commaRoundTrip;
  s || (s = Object.keys(t)), n.sort && s.sort(n.sort);
  let d = new WeakMap();
  for (let y = 0; y < s.length; ++y) {
    let h = s[y];
    (n.skipNulls && t[h] === null) ||
      ls(
        i,
        cs(
          t[h],
          h,
          o,
          l,
          n.allowEmptyArrays,
          n.strictNullHandling,
          n.skipNulls,
          n.encodeDotInKeys,
          n.encode ? n.encoder : null,
          n.filter,
          n.sort,
          n.allowDots,
          n.serializeDate,
          n.format,
          n.formatter,
          n.encodeValuesOnly,
          n.charset,
          d,
        ),
      );
  }
  let f = i.join(n.delimiter),
    m = n.addQueryPrefix === !0 ? "?" : "";
  return (
    n.charsetSentinel &&
      (n.charset === "iso-8859-1"
        ? (m += "utf8=%26%2310003%3B&")
        : (m += "utf8=%E2%9C%93&")),
    f.length > 0 ? m + f : ""
  );
}
var Xe = "4.92.1";
var us = !1,
  Ke,
  lr,
  Ca,
  Aa,
  Pa,
  cr,
  Sa,
  _n,
  ur,
  dr,
  mr,
  bn,
  fr;
function ds(r, e = { auto: !1 }) {
  if (us)
    throw new Error(
      `you must \`import 'openai/shims/${r.kind}'\` before importing anything else from openai`,
    );
  if (Ke)
    throw new Error(
      `can't \`import 'openai/shims/${r.kind}'\` after \`import 'openai/shims/${Ke}'\``,
    );
  (us = e.auto),
    (Ke = r.kind),
    (lr = r.fetch),
    (Ca = r.Request),
    (Aa = r.Response),
    (Pa = r.Headers),
    (cr = r.FormData),
    (Sa = r.Blob),
    (_n = r.File),
    (ur = r.ReadableStream),
    (dr = r.getMultipartRequestOptions),
    (mr = r.getDefaultAgent),
    (bn = r.fileFromPath),
    (fr = r.isFsReadStream);
}
var En = class {
  constructor(e) {
    this.body = e;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};
function ms({ manuallyImported: r } = {}) {
  let e = r
      ? "You may need to use polyfills"
      : "Add one of these imports before your first `import \u2026 from 'openai'`:\n- `import 'openai/shims/node'` (if you're running on Node)\n- `import 'openai/shims/web'` (otherwise)\n",
    t,
    n,
    s,
    a;
  try {
    (t = fetch), (n = Request), (s = Response), (a = Headers);
  } catch (i) {
    throw new Error(
      `this environment is missing the following Web Fetch API type: ${i.message}. ${e}`,
    );
  }
  return {
    kind: "web",
    fetch: t,
    Request: n,
    Response: s,
    Headers: a,
    FormData:
      typeof FormData != "undefined"
        ? FormData
        : class {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`,
              );
            }
          },
    Blob:
      typeof Blob != "undefined"
        ? Blob
        : class {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`,
              );
            }
          },
    File:
      typeof File != "undefined"
        ? File
        : class {
            constructor() {
              throw new Error(
                `file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`,
              );
            }
          },
    ReadableStream:
      typeof ReadableStream != "undefined"
        ? ReadableStream
        : class {
            constructor() {
              throw new Error(
                `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`,
              );
            }
          },
    getMultipartRequestOptions: async (i, o) => ({ ...o, body: new En(i) }),
    getDefaultAgent: (i) => {},
    fileFromPath: () => {
      throw new Error(
        "The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads",
      );
    },
    isFsReadStream: (i) => !1,
  };
}
var hr = () => {
  Ke || ds(ms(), { auto: !0 });
};
hr();
var C = class extends Error {},
  j = class r extends C {
    constructor(e, t, n, s) {
      super(`${r.makeMessage(e, t, n)}`),
        (this.status = e),
        (this.headers = s),
        (this.request_id = s == null ? void 0 : s["x-request-id"]),
        (this.error = t);
      let a = t;
      (this.code = a == null ? void 0 : a.code),
        (this.param = a == null ? void 0 : a.param),
        (this.type = a == null ? void 0 : a.type);
    }
    static makeMessage(e, t, n) {
      let s =
        t != null && t.message
          ? typeof t.message == "string"
            ? t.message
            : JSON.stringify(t.message)
          : t
            ? JSON.stringify(t)
            : n;
      return e && s
        ? `${e} ${s}`
        : e
          ? `${e} status code (no body)`
          : s || "(no status code or body)";
    }
    static generate(e, t, n, s) {
      if (!e || !s) return new Te({ message: n, cause: Cn(t) });
      let a = t == null ? void 0 : t.error;
      return e === 400
        ? new Wt(e, a, n, s)
        : e === 401
          ? new Ht(e, a, n, s)
          : e === 403
            ? new Jt(e, a, n, s)
            : e === 404
              ? new Xt(e, a, n, s)
              : e === 409
                ? new Kt(e, a, n, s)
                : e === 422
                  ? new Gt(e, a, n, s)
                  : e === 429
                    ? new Yt(e, a, n, s)
                    : e >= 500
                      ? new zt(e, a, n, s)
                      : new r(e, a, n, s);
    }
  },
  B = class extends j {
    constructor({ message: e } = {}) {
      super(void 0, void 0, e || "Request was aborted.", void 0);
    }
  },
  Te = class extends j {
    constructor({ message: e, cause: t }) {
      super(void 0, void 0, e || "Connection error.", void 0),
        t && (this.cause = t);
    }
  },
  Ie = class extends Te {
    constructor({ message: e } = {}) {
      super({ message: e != null ? e : "Request timed out." });
    }
  },
  Wt = class extends j {},
  Ht = class extends j {},
  Jt = class extends j {},
  Xt = class extends j {},
  Kt = class extends j {},
  Gt = class extends j {},
  Yt = class extends j {},
  zt = class extends j {},
  ht = class extends C {
    constructor() {
      super("Could not parse response content as the length limit was reached");
    }
  },
  pt = class extends C {
    constructor() {
      super(
        "Could not parse response content as the request was rejected by the content filter",
      );
    }
  };
var An = function (r, e, t, n, s) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !s)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !s : !e.has(r))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it",
      );
    return n === "a" ? s.call(r, t) : s ? (s.value = t) : e.set(r, t), t;
  },
  Ge = function (r, e, t, n) {
    if (t === "a" && !n)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it",
      );
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
  },
  K,
  Ye = class {
    constructor() {
      K.set(this, void 0),
        (this.buffer = new Uint8Array()),
        An(this, K, null, "f");
    }
    decode(e) {
      if (e == null) return [];
      let t =
          e instanceof ArrayBuffer
            ? new Uint8Array(e)
            : typeof e == "string"
              ? new TextEncoder().encode(e)
              : e,
        n = new Uint8Array(this.buffer.length + t.length);
      n.set(this.buffer), n.set(t, this.buffer.length), (this.buffer = n);
      let s = [],
        a;
      for (; (a = Fa(this.buffer, Ge(this, K, "f"))) != null; ) {
        if (a.carriage && Ge(this, K, "f") == null) {
          An(this, K, a.index, "f");
          continue;
        }
        if (
          Ge(this, K, "f") != null &&
          (a.index !== Ge(this, K, "f") + 1 || a.carriage)
        ) {
          s.push(this.decodeText(this.buffer.slice(0, Ge(this, K, "f") - 1))),
            (this.buffer = this.buffer.slice(Ge(this, K, "f"))),
            An(this, K, null, "f");
          continue;
        }
        let i = Ge(this, K, "f") !== null ? a.preceding - 1 : a.preceding,
          o = this.decodeText(this.buffer.slice(0, i));
        s.push(o),
          (this.buffer = this.buffer.slice(a.index)),
          An(this, K, null, "f");
      }
      return s;
    }
    decodeText(e) {
      var t;
      if (e == null) return "";
      if (typeof e == "string") return e;
      if (typeof Buffer != "undefined") {
        if (e instanceof Buffer) return e.toString();
        if (e instanceof Uint8Array) return Buffer.from(e).toString();
        throw new C(
          `Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`,
        );
      }
      if (typeof TextDecoder != "undefined") {
        if (e instanceof Uint8Array || e instanceof ArrayBuffer)
          return (
            (t = this.textDecoder) != null ||
              (this.textDecoder = new TextDecoder("utf8")),
            this.textDecoder.decode(e)
          );
        throw new C(
          `Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`,
        );
      }
      throw new C(
        "Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.",
      );
    }
    flush() {
      return this.buffer.length
        ? this.decode(`
`)
        : [];
    }
  };
K = new WeakMap();
Ye.NEWLINE_CHARS = new Set([
  `
`,
  "\r",
]);
Ye.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function Fa(r, e) {
  for (let s = e != null ? e : 0; s < r.length; s++) {
    if (r[s] === 10) return { preceding: s, index: s + 1, carriage: !1 };
    if (r[s] === 13) return { preceding: s, index: s + 1, carriage: !0 };
  }
  return null;
}
function fs(r) {
  for (let n = 0; n < r.length - 1; n++) {
    if ((r[n] === 10 && r[n + 1] === 10) || (r[n] === 13 && r[n + 1] === 13))
      return n + 2;
    if (
      r[n] === 13 &&
      r[n + 1] === 10 &&
      n + 3 < r.length &&
      r[n + 2] === 13 &&
      r[n + 3] === 10
    )
      return n + 4;
  }
  return -1;
}
function pr(r) {
  if (r[Symbol.asyncIterator]) return r;
  let e = r.getReader();
  return {
    async next() {
      try {
        let t = await e.read();
        return t != null && t.done && e.releaseLock(), t;
      } catch (t) {
        throw (e.releaseLock(), t);
      }
    },
    async return() {
      let t = e.cancel();
      return e.releaseLock(), await t, { done: !0, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}
var ce = class r {
  constructor(e, t) {
    (this.iterator = e), (this.controller = t);
  }
  static fromSSEResponse(e, t) {
    let n = !1;
    async function* s() {
      if (n)
        throw new Error(
          "Cannot iterate over a consumed stream, use `.tee()` to split the stream.",
        );
      n = !0;
      let a = !1;
      try {
        for await (let i of va(e, t))
          if (!a) {
            if (i.data.startsWith("[DONE]")) {
              a = !0;
              continue;
            }
            if (
              i.event === null ||
              i.event.startsWith("response.") ||
              i.event.startsWith("transcript.")
            ) {
              let o;
              try {
                o = JSON.parse(i.data);
              } catch (l) {
                throw (
                  (console.error("Could not parse message into JSON:", i.data),
                  console.error("From chunk:", i.raw),
                  l)
                );
              }
              if (o && o.error)
                throw new j(void 0, o.error, void 0, yr(e.headers));
              yield o;
            } else {
              let o;
              try {
                o = JSON.parse(i.data);
              } catch (l) {
                throw (
                  (console.error("Could not parse message into JSON:", i.data),
                  console.error("From chunk:", i.raw),
                  l)
                );
              }
              if (i.event == "error")
                throw new j(void 0, o.error, o.message, void 0);
              yield { event: i.event, data: o };
            }
          }
        a = !0;
      } catch (i) {
        if (i instanceof Error && i.name === "AbortError") return;
        throw i;
      } finally {
        a || t.abort();
      }
    }
    return new r(s, t);
  }
  static fromReadableStream(e, t) {
    let n = !1;
    async function* s() {
      let i = new Ye(),
        o = pr(e);
      for await (let l of o) for (let d of i.decode(l)) yield d;
      for (let l of i.flush()) yield l;
    }
    async function* a() {
      if (n)
        throw new Error(
          "Cannot iterate over a consumed stream, use `.tee()` to split the stream.",
        );
      n = !0;
      let i = !1;
      try {
        for await (let o of s()) i || (o && (yield JSON.parse(o)));
        i = !0;
      } catch (o) {
        if (o instanceof Error && o.name === "AbortError") return;
        throw o;
      } finally {
        i || t.abort();
      }
    }
    return new r(a, t);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  tee() {
    let e = [],
      t = [],
      n = this.iterator(),
      s = (a) => ({
        next: () => {
          if (a.length === 0) {
            let i = n.next();
            e.push(i), t.push(i);
          }
          return a.shift();
        },
      });
    return [
      new r(() => s(e), this.controller),
      new r(() => s(t), this.controller),
    ];
  }
  toReadableStream() {
    let e = this,
      t,
      n = new TextEncoder();
    return new ur({
      async start() {
        t = e[Symbol.asyncIterator]();
      },
      async pull(s) {
        try {
          let { value: a, done: i } = await t.next();
          if (i) return s.close();
          let o = n.encode(
            JSON.stringify(a) +
              `
`,
          );
          s.enqueue(o);
        } catch (a) {
          s.error(a);
        }
      },
      async cancel() {
        var s;
        await ((s = t.return) == null ? void 0 : s.call(t));
      },
    });
  }
};
async function* va(r, e) {
  if (!r.body)
    throw (
      (e.abort(), new C("Attempted to iterate over a response with no body"))
    );
  let t = new gr(),
    n = new Ye(),
    s = pr(r.body);
  for await (let a of Ra(s))
    for (let i of n.decode(a)) {
      let o = t.decode(i);
      o && (yield o);
    }
  for (let a of n.flush()) {
    let i = t.decode(a);
    i && (yield i);
  }
}
async function* Ra(r) {
  let e = new Uint8Array();
  for await (let t of r) {
    if (t == null) continue;
    let n =
        t instanceof ArrayBuffer
          ? new Uint8Array(t)
          : typeof t == "string"
            ? new TextEncoder().encode(t)
            : t,
      s = new Uint8Array(e.length + n.length);
    s.set(e), s.set(n, e.length), (e = s);
    let a;
    for (; (a = fs(e)) !== -1; ) yield e.slice(0, a), (e = e.slice(a));
  }
  e.length > 0 && (yield e);
}
var gr = class {
  constructor() {
    (this.event = null), (this.data = []), (this.chunks = []);
  }
  decode(e) {
    if ((e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e)) {
      if (!this.event && !this.data.length) return null;
      let a = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks,
      };
      return (this.event = null), (this.data = []), (this.chunks = []), a;
    }
    if ((this.chunks.push(e), e.startsWith(":"))) return null;
    let [t, n, s] = Ma(e, ":");
    return (
      s.startsWith(" ") && (s = s.substring(1)),
      t === "event" ? (this.event = s) : t === "data" && this.data.push(s),
      null
    );
  }
};
function Ma(r, e) {
  let t = r.indexOf(e);
  return t !== -1
    ? [r.substring(0, t), e, r.substring(t + e.length)]
    : [r, "", ""];
}
var hs = (r) =>
    r != null &&
    typeof r == "object" &&
    typeof r.url == "string" &&
    typeof r.blob == "function",
  ps = (r) =>
    r != null &&
    typeof r == "object" &&
    typeof r.name == "string" &&
    typeof r.lastModified == "number" &&
    Qt(r),
  Qt = (r) =>
    r != null &&
    typeof r == "object" &&
    typeof r.size == "number" &&
    typeof r.type == "string" &&
    typeof r.text == "function" &&
    typeof r.slice == "function" &&
    typeof r.arrayBuffer == "function",
  Da = (r) => ps(r) || hs(r) || fr(r);
async function _r(r, e, t) {
  var s, a, i;
  if (((r = await r), ps(r))) return r;
  if (hs(r)) {
    let o = await r.blob();
    e ||
      (e =
        (s = new URL(r.url).pathname.split(/[\\/]/).pop()) != null
          ? s
          : "unknown_file");
    let l = Qt(o) ? [await o.arrayBuffer()] : [o];
    return new _n(l, e, t);
  }
  let n = await Na(r);
  if (
    (e || (e = (a = ka(r)) != null ? a : "unknown_file"),
    !(t != null && t.type))
  ) {
    let o = (i = n[0]) == null ? void 0 : i.type;
    typeof o == "string" && (t = { ...t, type: o });
  }
  return new _n(n, e, t);
}
async function Na(r) {
  var t;
  let e = [];
  if (typeof r == "string" || ArrayBuffer.isView(r) || r instanceof ArrayBuffer)
    e.push(r);
  else if (Qt(r)) e.push(await r.arrayBuffer());
  else if ($a(r)) for await (let n of r) e.push(n);
  else
    throw new Error(
      `Unexpected data type: ${typeof r}; constructor: ${(t = r == null ? void 0 : r.constructor) == null ? void 0 : t.name}; props: ${Oa(r)}`,
    );
  return e;
}
function Oa(r) {
  return `[${Object.getOwnPropertyNames(r)
    .map((t) => `"${t}"`)
    .join(", ")}]`;
}
function ka(r) {
  var e;
  return (
    wr(r.name) ||
    wr(r.filename) ||
    ((e = wr(r.path)) == null ? void 0 : e.split(/[\\/]/).pop())
  );
}
var wr = (r) => {
    if (typeof r == "string") return r;
    if (typeof Buffer != "undefined" && r instanceof Buffer) return String(r);
  },
  $a = (r) =>
    r != null &&
    typeof r == "object" &&
    typeof r[Symbol.asyncIterator] == "function",
  br = (r) =>
    r &&
    typeof r == "object" &&
    r.body &&
    r[Symbol.toStringTag] === "MultipartBody";
var ee = async (r) => {
    let e = await gs(r.body);
    return dr(e, r);
  },
  gs = async (r) => {
    let e = new cr();
    return (
      await Promise.all(Object.entries(r || {}).map(([t, n]) => xr(e, t, n))), e
    );
  };
var xr = async (r, e, t) => {
  if (t !== void 0) {
    if (t == null)
      throw new TypeError(
        `Received null for "${e}"; to pass null in FormData, you must use the string 'null'`,
      );
    if (typeof t == "string" || typeof t == "number" || typeof t == "boolean")
      r.append(e, String(t));
    else if (Da(t)) {
      let n = await _r(t);
      r.append(e, n);
    } else if (Array.isArray(t))
      await Promise.all(t.map((n) => xr(r, e + "[]", n)));
    else if (typeof t == "object")
      await Promise.all(
        Object.entries(t).map(([n, s]) => xr(r, `${e}[${n}]`, s)),
      );
    else
      throw new TypeError(
        `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${t} instead`,
      );
  }
};
var Ba = function (r, e, t, n, s) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !s)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !s : !e.has(r))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it",
      );
    return n === "a" ? s.call(r, t) : s ? (s.value = t) : e.set(r, t), t;
  },
  Ua = function (r, e, t, n) {
    if (t === "a" && !n)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it",
      );
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
  },
  Pn;
hr();
async function bs(r) {
  var i;
  let { response: e } = r;
  if (r.options.stream)
    return (
      _e("response", e.status, e.url, e.headers, e.body),
      r.options.__streamClass
        ? r.options.__streamClass.fromSSEResponse(e, r.controller)
        : ce.fromSSEResponse(e, r.controller)
    );
  if (e.status === 204) return null;
  if (r.options.__binaryResponse) return e;
  let t = e.headers.get("content-type"),
    n = (i = t == null ? void 0 : t.split(";")[0]) == null ? void 0 : i.trim();
  if (
    (n == null ? void 0 : n.includes("application/json")) ||
    (n == null ? void 0 : n.endsWith("+json"))
  ) {
    let o = await e.json();
    return _e("response", e.status, e.url, e.headers, o), Es(o, e);
  }
  let a = await e.text();
  return _e("response", e.status, e.url, e.headers, a), a;
}
function Es(r, e) {
  return !r || typeof r != "object" || Array.isArray(r)
    ? r
    : Object.defineProperty(r, "_request_id", {
        value: e.headers.get("x-request-id"),
        enumerable: !1,
      });
}
var In = class r extends Promise {
    constructor(e, t = bs) {
      super((n) => {
        n(null);
      }),
        (this.responsePromise = e),
        (this.parseResponse = t);
    }
    _thenUnwrap(e) {
      return new r(this.responsePromise, async (t) =>
        Es(e(await this.parseResponse(t), t), t.response),
      );
    }
    asResponse() {
      return this.responsePromise.then((e) => e.response);
    }
    async withResponse() {
      let [e, t] = await Promise.all([this.parse(), this.asResponse()]);
      return {
        data: e,
        response: t,
        request_id: t.headers.get("x-request-id"),
      };
    }
    parse() {
      return (
        this.parsedPromise ||
          (this.parsedPromise = this.responsePromise.then(this.parseResponse)),
        this.parsedPromise
      );
    }
    then(e, t) {
      return this.parse().then(e, t);
    }
    catch(e) {
      return this.parse().catch(e);
    }
    finally(e) {
      return this.parse().finally(e);
    }
  },
  Fn = class {
    constructor({
      baseURL: e,
      maxRetries: t = 2,
      timeout: n = 6e5,
      httpAgent: s,
      fetch: a,
    }) {
      (this.baseURL = e),
        (this.maxRetries = Er("maxRetries", t)),
        (this.timeout = Er("timeout", n)),
        (this.httpAgent = s),
        (this.fetch = a != null ? a : lr);
    }
    authHeaders(e) {
      return {};
    }
    defaultHeaders(e) {
      return {
        Accept: "application/json",
        "Content-Type": "application/json",
        "User-Agent": this.getUserAgent(),
        ...Wa(),
        ...this.authHeaders(e),
      };
    }
    validateHeaders(e, t) {}
    defaultIdempotencyKey() {
      return `stainless-node-retry-${Ka()}`;
    }
    get(e, t) {
      return this.methodRequest("get", e, t);
    }
    post(e, t) {
      return this.methodRequest("post", e, t);
    }
    patch(e, t) {
      return this.methodRequest("patch", e, t);
    }
    put(e, t) {
      return this.methodRequest("put", e, t);
    }
    delete(e, t) {
      return this.methodRequest("delete", e, t);
    }
    methodRequest(e, t, n) {
      return this.request(
        Promise.resolve(n).then(async (s) => {
          let a =
            s && Qt(s == null ? void 0 : s.body)
              ? new DataView(await s.body.arrayBuffer())
              : (s == null ? void 0 : s.body) instanceof DataView
                ? s.body
                : (s == null ? void 0 : s.body) instanceof ArrayBuffer
                  ? new DataView(s.body)
                  : s && ArrayBuffer.isView(s == null ? void 0 : s.body)
                    ? new DataView(s.body.buffer)
                    : s == null
                      ? void 0
                      : s.body;
          return { method: e, path: t, ...s, body: a };
        }),
      );
    }
    getAPIList(e, t, n) {
      return this.requestAPIList(t, { method: "get", path: e, ...n });
    }
    calculateContentLength(e) {
      if (typeof e == "string") {
        if (typeof Buffer != "undefined")
          return Buffer.byteLength(e, "utf8").toString();
        if (typeof TextEncoder != "undefined")
          return new TextEncoder().encode(e).length.toString();
      } else if (ArrayBuffer.isView(e)) return e.byteLength.toString();
      return null;
    }
    buildRequest(e, { retryCount: t = 0 } = {}) {
      var b, x, u, p, w, g;
      e = { ...e };
      let { method: n, path: s, query: a, headers: i = {} } = e,
        o =
          ArrayBuffer.isView(e.body) ||
          (e.__binaryRequest && typeof e.body == "string")
            ? e.body
            : br(e.body)
              ? e.body.body
              : e.body
                ? JSON.stringify(e.body, null, 2)
                : null,
        l = this.calculateContentLength(o),
        d = this.buildURL(s, a);
      "timeout" in e && Er("timeout", e.timeout),
        (e.timeout = (b = e.timeout) != null ? b : this.timeout);
      let f =
          (u = (x = e.httpAgent) != null ? x : this.httpAgent) != null
            ? u
            : mr(d),
        m = e.timeout + 1e3;
      typeof ((p = f == null ? void 0 : f.options) == null
        ? void 0
        : p.timeout) == "number" &&
        m > ((w = f.options.timeout) != null ? w : 0) &&
        (f.options.timeout = m),
        this.idempotencyHeader &&
          n !== "get" &&
          (e.idempotencyKey ||
            (e.idempotencyKey = this.defaultIdempotencyKey()),
          (i[this.idempotencyHeader] = e.idempotencyKey));
      let y = this.buildHeaders({
        options: e,
        headers: i,
        contentLength: l,
        retryCount: t,
      });
      return {
        req: {
          method: n,
          ...(o && { body: o }),
          headers: y,
          ...(f && { agent: f }),
          signal: (g = e.signal) != null ? g : null,
        },
        url: d,
        timeout: e.timeout,
      };
    }
    buildHeaders({ options: e, headers: t, contentLength: n, retryCount: s }) {
      let a = {};
      n && (a["content-length"] = n);
      let i = this.defaultHeaders(e);
      return (
        xs(a, i),
        xs(a, t),
        br(e.body) && Ke !== "node" && delete a["content-type"],
        Tn(i, "x-stainless-retry-count") === void 0 &&
          Tn(t, "x-stainless-retry-count") === void 0 &&
          (a["x-stainless-retry-count"] = String(s)),
        Tn(i, "x-stainless-timeout") === void 0 &&
          Tn(t, "x-stainless-timeout") === void 0 &&
          e.timeout &&
          (a["x-stainless-timeout"] = String(Math.trunc(e.timeout / 1e3))),
        this.validateHeaders(a, t),
        a
      );
    }
    async prepareOptions(e) {}
    async prepareRequest(e, { url: t, options: n }) {}
    parseHeaders(e) {
      return e
        ? Symbol.iterator in e
          ? Object.fromEntries(Array.from(e).map((t) => [...t]))
          : { ...e }
        : {};
    }
    makeStatusError(e, t, n, s) {
      return j.generate(e, t, n, s);
    }
    request(e, t = null) {
      return new In(this.makeRequest(e, t));
    }
    async makeRequest(e, t) {
      var m, y, h;
      let n = await e,
        s = (m = n.maxRetries) != null ? m : this.maxRetries;
      t == null && (t = s), await this.prepareOptions(n);
      let {
        req: a,
        url: i,
        timeout: o,
      } = this.buildRequest(n, { retryCount: s - t });
      if (
        (await this.prepareRequest(a, { url: i, options: n }),
        _e("request", i, n, a.headers),
        (y = n.signal) != null && y.aborted)
      )
        throw new B();
      let l = new AbortController(),
        d = await this.fetchWithTimeout(i, a, o, l).catch(Cn);
      if (d instanceof Error) {
        if ((h = n.signal) != null && h.aborted) throw new B();
        if (t) return this.retryRequest(n, t);
        throw d.name === "AbortError" ? new Ie() : new Te({ cause: d });
      }
      let f = yr(d.headers);
      if (!d.ok) {
        if (t && this.shouldRetry(d)) {
          let g = `retrying, ${t} attempts remaining`;
          return (
            _e(`response (error; ${g})`, d.status, i, f),
            this.retryRequest(n, t, f)
          );
        }
        let b = await d.text().catch((g) => Cn(g).message),
          x = Ha(b),
          u = x ? void 0 : b;
        throw (
          (_e(
            `response (error; ${t ? "(error; no more retries left)" : "(error; not retryable)"})`,
            d.status,
            i,
            f,
            u,
          ),
          this.makeStatusError(d.status, x, u, f))
        );
      }
      return { response: d, options: n, controller: l };
    }
    requestAPIList(e, t) {
      let n = this.makeRequest(t, null);
      return new Cr(this, n, e);
    }
    buildURL(e, t) {
      let n = Xa(e)
          ? new URL(e)
          : new URL(
              this.baseURL +
                (this.baseURL.endsWith("/") && e.startsWith("/")
                  ? e.slice(1)
                  : e),
            ),
        s = this.defaultQuery();
      return (
        Cs(s) || (t = { ...s, ...t }),
        typeof t == "object" &&
          t &&
          !Array.isArray(t) &&
          (n.search = this.stringifyQuery(t)),
        n.toString()
      );
    }
    stringifyQuery(e) {
      return Object.entries(e)
        .filter(([t, n]) => typeof n != "undefined")
        .map(([t, n]) => {
          if (
            typeof n == "string" ||
            typeof n == "number" ||
            typeof n == "boolean"
          )
            return `${encodeURIComponent(t)}=${encodeURIComponent(n)}`;
          if (n === null) return `${encodeURIComponent(t)}=`;
          throw new C(
            `Cannot stringify type ${typeof n}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`,
          );
        })
        .join("&");
    }
    async fetchWithTimeout(e, t, n, s) {
      let { signal: a, ...i } = t || {};
      a && a.addEventListener("abort", () => s.abort());
      let o = setTimeout(() => s.abort(), n),
        l = { signal: s.signal, ...i };
      return (
        l.method && (l.method = l.method.toUpperCase()),
        this.fetch.call(void 0, e, l).finally(() => {
          clearTimeout(o);
        })
      );
    }
    shouldRetry(e) {
      let t = e.headers.get("x-should-retry");
      return t === "true"
        ? !0
        : t === "false"
          ? !1
          : e.status === 408 ||
            e.status === 409 ||
            e.status === 429 ||
            e.status >= 500;
    }
    async retryRequest(e, t, n) {
      var o;
      let s,
        a = n == null ? void 0 : n["retry-after-ms"];
      if (a) {
        let l = parseFloat(a);
        Number.isNaN(l) || (s = l);
      }
      let i = n == null ? void 0 : n["retry-after"];
      if (i && !s) {
        let l = parseFloat(i);
        Number.isNaN(l) ? (s = Date.parse(i) - Date.now()) : (s = l * 1e3);
      }
      if (!(s && 0 <= s && s < 60 * 1e3)) {
        let l = (o = e.maxRetries) != null ? o : this.maxRetries;
        s = this.calculateDefaultRetryTimeoutMillis(t, l);
      }
      return await be(s), this.makeRequest(e, t - 1);
    }
    calculateDefaultRetryTimeoutMillis(e, t) {
      let a = t - e,
        i = Math.min(0.5 * Math.pow(2, a), 8),
        o = 1 - Math.random() * 0.25;
      return i * o * 1e3;
    }
    getUserAgent() {
      return `${this.constructor.name}/JS ${Xe}`;
    }
  },
  Zt = class {
    constructor(e, t, n, s) {
      Pn.set(this, void 0),
        Ba(this, Pn, e, "f"),
        (this.options = s),
        (this.response = t),
        (this.body = n);
    }
    hasNextPage() {
      return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1;
    }
    async getNextPage() {
      let e = this.nextPageInfo();
      if (!e)
        throw new C(
          "No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.",
        );
      let t = { ...this.options };
      if ("params" in e && typeof t.query == "object")
        t.query = { ...t.query, ...e.params };
      else if ("url" in e) {
        let n = [
          ...Object.entries(t.query || {}),
          ...e.url.searchParams.entries(),
        ];
        for (let [s, a] of n) e.url.searchParams.set(s, a);
        (t.query = void 0), (t.path = e.url.toString());
      }
      return await Ua(this, Pn, "f").requestAPIList(this.constructor, t);
    }
    async *iterPages() {
      let e = this;
      for (yield e; e.hasNextPage(); ) (e = await e.getNextPage()), yield e;
    }
    async *[((Pn = new WeakMap()), Symbol.asyncIterator)]() {
      for await (let e of this.iterPages())
        for (let t of e.getPaginatedItems()) yield t;
    }
  },
  Cr = class extends In {
    constructor(e, t, n) {
      super(t, async (s) => new n(e, s.response, await bs(s), s.options));
    }
    async *[Symbol.asyncIterator]() {
      let e = await this;
      for await (let t of e) yield t;
    }
  },
  yr = (r) =>
    new Proxy(Object.fromEntries(r.entries()), {
      get(e, t) {
        let n = t.toString();
        return e[n.toLowerCase()] || e[n];
      },
    }),
  ja = {
    method: !0,
    path: !0,
    query: !0,
    body: !0,
    headers: !0,
    maxRetries: !0,
    stream: !0,
    timeout: !0,
    httpAgent: !0,
    signal: !0,
    idempotencyKey: !0,
    __metadata: !0,
    __binaryRequest: !0,
    __binaryResponse: !0,
    __streamClass: !0,
  },
  F = (r) =>
    typeof r == "object" &&
    r !== null &&
    !Cs(r) &&
    Object.keys(r).every((e) => As(ja, e)),
  Va = () => {
    var e, t;
    if (typeof Deno != "undefined" && Deno.build != null)
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": Xe,
        "X-Stainless-OS": ws(Deno.build.os),
        "X-Stainless-Arch": ys(Deno.build.arch),
        "X-Stainless-Runtime": "deno",
        "X-Stainless-Runtime-Version":
          typeof Deno.version == "string"
            ? Deno.version
            : (t = (e = Deno.version) == null ? void 0 : e.deno) != null
              ? t
              : "unknown",
      };
    if (typeof EdgeRuntime != "undefined")
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": Xe,
        "X-Stainless-OS": "Unknown",
        "X-Stainless-Arch": `other:${EdgeRuntime}`,
        "X-Stainless-Runtime": "edge",
        "X-Stainless-Runtime-Version": process.version,
      };
    if (
      Object.prototype.toString.call(
        typeof process != "undefined" ? process : 0,
      ) === "[object process]"
    )
      return {
        "X-Stainless-Lang": "js",
        "X-Stainless-Package-Version": Xe,
        "X-Stainless-OS": ws(process.platform),
        "X-Stainless-Arch": ys(process.arch),
        "X-Stainless-Runtime": "node",
        "X-Stainless-Runtime-Version": process.version,
      };
    let r = qa();
    return r
      ? {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": Xe,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": `browser:${r.browser}`,
          "X-Stainless-Runtime-Version": r.version,
        }
      : {
          "X-Stainless-Lang": "js",
          "X-Stainless-Package-Version": Xe,
          "X-Stainless-OS": "Unknown",
          "X-Stainless-Arch": "unknown",
          "X-Stainless-Runtime": "unknown",
          "X-Stainless-Runtime-Version": "unknown",
        };
  };
function qa() {
  if (typeof navigator == "undefined" || !navigator) return null;
  let r = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    {
      key: "safari",
      pattern:
        /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/,
    },
  ];
  for (let { key: e, pattern: t } of r) {
    let n = t.exec(navigator.userAgent);
    if (n) {
      let s = n[1] || 0,
        a = n[2] || 0,
        i = n[3] || 0;
      return { browser: e, version: `${s}.${a}.${i}` };
    }
  }
  return null;
}
var ys = (r) =>
    r === "x32"
      ? "x32"
      : r === "x86_64" || r === "x64"
        ? "x64"
        : r === "arm"
          ? "arm"
          : r === "aarch64" || r === "arm64"
            ? "arm64"
            : r
              ? `other:${r}`
              : "unknown",
  ws = (r) => (
    (r = r.toLowerCase()),
    r.includes("ios")
      ? "iOS"
      : r === "android"
        ? "Android"
        : r === "darwin"
          ? "MacOS"
          : r === "win32"
            ? "Windows"
            : r === "freebsd"
              ? "FreeBSD"
              : r === "openbsd"
                ? "OpenBSD"
                : r === "linux"
                  ? "Linux"
                  : r
                    ? `Other:${r}`
                    : "Unknown"
  ),
  Sn,
  Wa = () => (Sn != null ? Sn : (Sn = Va())),
  Ha = (r) => {
    try {
      return JSON.parse(r);
    } catch (e) {
      return;
    }
  },
  Ja = /^[a-z][a-z0-9+.-]*:/i,
  Xa = (r) => Ja.test(r),
  be = (r) => new Promise((e) => setTimeout(e, r)),
  Er = (r, e) => {
    if (typeof e != "number" || !Number.isInteger(e))
      throw new C(`${r} must be an integer`);
    if (e < 0) throw new C(`${r} must be a positive integer`);
    return e;
  },
  Cn = (r) => {
    if (r instanceof Error) return r;
    if (typeof r == "object" && r !== null)
      try {
        return new Error(JSON.stringify(r));
      } catch (e) {}
    return new Error(r);
  };
var en = (r) => {
  var e, t, n, s, a, i;
  if (typeof process != "undefined")
    return (n =
      (t = (e = process.env) == null ? void 0 : e[r]) == null
        ? void 0
        : t.trim()) != null
      ? n
      : void 0;
  if (typeof Deno != "undefined")
    return (i =
      (a = (s = Deno.env) == null ? void 0 : s.get) == null
        ? void 0
        : a.call(s, r)) == null
      ? void 0
      : i.trim();
};
function Cs(r) {
  if (!r) return !0;
  for (let e in r) return !1;
  return !0;
}
function As(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function xs(r, e) {
  for (let t in e) {
    if (!As(e, t)) continue;
    let n = t.toLowerCase();
    if (!n) continue;
    let s = e[t];
    s === null ? delete r[n] : s !== void 0 && (r[n] = s);
  }
}
var _s = new Set(["authorization", "api-key"]);
function _e(r, ...e) {
  var t;
  if (
    typeof process != "undefined" &&
    ((t = process == null ? void 0 : process.env) == null
      ? void 0
      : t.DEBUG) === "true"
  ) {
    let n = e.map((s) => {
      if (!s) return s;
      if (s.headers) {
        let i = { ...s, headers: { ...s.headers } };
        for (let o in s.headers)
          _s.has(o.toLowerCase()) && (i.headers[o] = "REDACTED");
        return i;
      }
      let a = null;
      for (let i in s)
        _s.has(i.toLowerCase()) &&
          (a != null || (a = { ...s }), (a[i] = "REDACTED"));
      return a != null ? a : s;
    });
    console.log(`OpenAI:DEBUG:${r}`, ...n);
  }
}
var Ka = () =>
    "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (r) => {
      let e = (Math.random() * 16) | 0;
      return (r === "x" ? e : (e & 3) | 8).toString(16);
    }),
  Ps = () =>
    typeof window != "undefined" &&
    typeof window.document != "undefined" &&
    typeof navigator != "undefined",
  Ga = (r) => typeof (r == null ? void 0 : r.get) == "function";
var Tn = (r, e) => {
  var n;
  let t = e.toLowerCase();
  if (Ga(r)) {
    let s =
      ((n = e[0]) == null ? void 0 : n.toUpperCase()) +
      e.substring(1).replace(/([^\w])(\w)/g, (a, i, o) => i + o.toUpperCase());
    for (let a of [e, t, e.toUpperCase(), s]) {
      let i = r.get(a);
      if (i) return i;
    }
  }
  for (let [s, a] of Object.entries(r))
    if (s.toLowerCase() === t)
      return Array.isArray(a)
        ? (a.length <= 1 ||
            console.warn(
              `Received ${a.length} entries for the ${e} header, using the first entry.`,
            ),
          a[0])
        : a;
};
var Ss = (r) => {
  if (typeof Buffer != "undefined") {
    let e = Buffer.from(r, "base64");
    return Array.from(
      new Float32Array(
        e.buffer,
        e.byteOffset,
        e.length / Float32Array.BYTES_PER_ELEMENT,
      ),
    );
  } else {
    let e = atob(r),
      t = e.length,
      n = new Uint8Array(t);
    for (let s = 0; s < t; s++) n[s] = e.charCodeAt(s);
    return Array.from(new Float32Array(n.buffer));
  }
};
function tn(r) {
  return r != null && typeof r == "object" && !Array.isArray(r);
}
var ve = class extends Zt {
    constructor(e, t, n, s) {
      super(e, t, n, s), (this.data = n.data || []), (this.object = n.object);
    }
    getPaginatedItems() {
      var e;
      return (e = this.data) != null ? e : [];
    }
    nextPageParams() {
      return null;
    }
    nextPageInfo() {
      return null;
    }
  },
  O = class extends Zt {
    constructor(e, t, n, s) {
      super(e, t, n, s),
        (this.data = n.data || []),
        (this.has_more = n.has_more || !1);
    }
    getPaginatedItems() {
      var e;
      return (e = this.data) != null ? e : [];
    }
    hasNextPage() {
      return this.has_more === !1 ? !1 : super.hasNextPage();
    }
    nextPageParams() {
      let e = this.nextPageInfo();
      if (!e) return null;
      if ("params" in e) return e.params;
      let t = Object.fromEntries(e.url.searchParams);
      return Object.keys(t).length ? t : null;
    }
    nextPageInfo() {
      var n;
      let e = this.getPaginatedItems();
      if (!e.length) return null;
      let t = (n = e[e.length - 1]) == null ? void 0 : n.id;
      return t ? { params: { after: t } } : null;
    }
  };
var _ = class {
  constructor(e) {
    this._client = e;
  }
};
var gt = class extends _ {
  list(e, t = {}, n) {
    return F(t)
      ? this.list(e, {}, t)
      : this._client.getAPIList(`/chat/completions/${e}/messages`, vn, {
          query: t,
          ...n,
        });
  }
};
var Re = class extends _ {
    constructor() {
      super(...arguments), (this.messages = new gt(this._client));
    }
    create(e, t) {
      var n;
      return this._client.post("/chat/completions", {
        body: e,
        ...t,
        stream: (n = e.stream) != null ? n : !1,
      });
    }
    retrieve(e, t) {
      return this._client.get(`/chat/completions/${e}`, t);
    }
    update(e, t, n) {
      return this._client.post(`/chat/completions/${e}`, { body: t, ...n });
    }
    list(e = {}, t) {
      return F(e)
        ? this.list({}, e)
        : this._client.getAPIList("/chat/completions", Me, { query: e, ...t });
    }
    del(e, t) {
      return this._client.delete(`/chat/completions/${e}`, t);
    }
  },
  Me = class extends O {},
  vn = class extends O {};
Re.ChatCompletionsPage = Me;
Re.Messages = gt;
var Ee = class extends _ {
  constructor() {
    super(...arguments), (this.completions = new Re(this._client));
  }
};
Ee.Completions = Re;
Ee.ChatCompletionsPage = Me;
var yt = class extends _ {
  create(e, t) {
    return this._client.post("/audio/speech", {
      body: e,
      ...t,
      headers: {
        Accept: "application/octet-stream",
        ...(t == null ? void 0 : t.headers),
      },
      __binaryResponse: !0,
    });
  }
};
var wt = class extends _ {
  create(e, t) {
    var n;
    return this._client.post(
      "/audio/transcriptions",
      ee({
        body: e,
        ...t,
        stream: (n = e.stream) != null ? n : !1,
        __metadata: { model: e.model },
      }),
    );
  }
};
var xt = class extends _ {
  create(e, t) {
    return this._client.post(
      "/audio/translations",
      ee({ body: e, ...t, __metadata: { model: e.model } }),
    );
  }
};
var ue = class extends _ {
  constructor() {
    super(...arguments),
      (this.transcriptions = new wt(this._client)),
      (this.translations = new xt(this._client)),
      (this.speech = new yt(this._client));
  }
};
ue.Transcriptions = wt;
ue.Translations = xt;
ue.Speech = yt;
var De = class extends _ {
    create(e, t) {
      return this._client.post("/batches", { body: e, ...t });
    }
    retrieve(e, t) {
      return this._client.get(`/batches/${e}`, t);
    }
    list(e = {}, t) {
      return F(e)
        ? this.list({}, e)
        : this._client.getAPIList("/batches", ze, { query: e, ...t });
    }
    cancel(e, t) {
      return this._client.post(`/batches/${e}/cancel`, t);
    }
  },
  ze = class extends O {};
De.BatchesPage = ze;
var Qe = class extends _ {
    create(e, t) {
      return this._client.post("/assistants", {
        body: e,
        ...t,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(t == null ? void 0 : t.headers),
        },
      });
    }
    retrieve(e, t) {
      return this._client.get(`/assistants/${e}`, {
        ...t,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(t == null ? void 0 : t.headers),
        },
      });
    }
    update(e, t, n) {
      return this._client.post(`/assistants/${e}`, {
        body: t,
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
    list(e = {}, t) {
      return F(e)
        ? this.list({}, e)
        : this._client.getAPIList("/assistants", _t, {
            query: e,
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(t == null ? void 0 : t.headers),
            },
          });
    }
    del(e, t) {
      return this._client.delete(`/assistants/${e}`, {
        ...t,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(t == null ? void 0 : t.headers),
        },
      });
    }
  },
  _t = class extends O {};
Qe.AssistantsPage = _t;
function Ar(r) {
  return typeof r.parse == "function";
}
var Ne = (r) => (r == null ? void 0 : r.role) === "assistant",
  Pr = (r) => (r == null ? void 0 : r.role) === "function",
  Sr = (r) => (r == null ? void 0 : r.role) === "tool";
var te = function (r, e, t, n, s) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !s)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !s : !e.has(r))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it",
      );
    return n === "a" ? s.call(r, t) : s ? (s.value = t) : e.set(r, t), t;
  },
  L = function (r, e, t, n) {
    if (t === "a" && !n)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it",
      );
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
  },
  Tr,
  Rn,
  Mn,
  nn,
  rn,
  Dn,
  sn,
  Ce,
  an,
  Nn,
  On,
  bt,
  Ts,
  Oe = class {
    constructor() {
      Tr.add(this),
        (this.controller = new AbortController()),
        Rn.set(this, void 0),
        Mn.set(this, () => {}),
        nn.set(this, () => {}),
        rn.set(this, void 0),
        Dn.set(this, () => {}),
        sn.set(this, () => {}),
        Ce.set(this, {}),
        an.set(this, !1),
        Nn.set(this, !1),
        On.set(this, !1),
        bt.set(this, !1),
        te(
          this,
          Rn,
          new Promise((e, t) => {
            te(this, Mn, e, "f"), te(this, nn, t, "f");
          }),
          "f",
        ),
        te(
          this,
          rn,
          new Promise((e, t) => {
            te(this, Dn, e, "f"), te(this, sn, t, "f");
          }),
          "f",
        ),
        L(this, Rn, "f").catch(() => {}),
        L(this, rn, "f").catch(() => {});
    }
    _run(e) {
      setTimeout(() => {
        e().then(
          () => {
            this._emitFinal(), this._emit("end");
          },
          L(this, Tr, "m", Ts).bind(this),
        );
      }, 0);
    }
    _connected() {
      this.ended || (L(this, Mn, "f").call(this), this._emit("connect"));
    }
    get ended() {
      return L(this, an, "f");
    }
    get errored() {
      return L(this, Nn, "f");
    }
    get aborted() {
      return L(this, On, "f");
    }
    abort() {
      this.controller.abort();
    }
    on(e, t) {
      return (
        (L(this, Ce, "f")[e] || (L(this, Ce, "f")[e] = [])).push({
          listener: t,
        }),
        this
      );
    }
    off(e, t) {
      let n = L(this, Ce, "f")[e];
      if (!n) return this;
      let s = n.findIndex((a) => a.listener === t);
      return s >= 0 && n.splice(s, 1), this;
    }
    once(e, t) {
      return (
        (L(this, Ce, "f")[e] || (L(this, Ce, "f")[e] = [])).push({
          listener: t,
          once: !0,
        }),
        this
      );
    }
    emitted(e) {
      return new Promise((t, n) => {
        te(this, bt, !0, "f"),
          e !== "error" && this.once("error", n),
          this.once(e, t);
      });
    }
    async done() {
      te(this, bt, !0, "f"), await L(this, rn, "f");
    }
    _emit(e, ...t) {
      if (L(this, an, "f")) return;
      e === "end" && (te(this, an, !0, "f"), L(this, Dn, "f").call(this));
      let n = L(this, Ce, "f")[e];
      if (
        (n &&
          ((L(this, Ce, "f")[e] = n.filter((s) => !s.once)),
          n.forEach(({ listener: s }) => s(...t))),
        e === "abort")
      ) {
        let s = t[0];
        !L(this, bt, "f") && !(n != null && n.length) && Promise.reject(s),
          L(this, nn, "f").call(this, s),
          L(this, sn, "f").call(this, s),
          this._emit("end");
        return;
      }
      if (e === "error") {
        let s = t[0];
        !L(this, bt, "f") && !(n != null && n.length) && Promise.reject(s),
          L(this, nn, "f").call(this, s),
          L(this, sn, "f").call(this, s),
          this._emit("end");
      }
    }
    _emitFinal() {}
  };
(Rn = new WeakMap()),
  (Mn = new WeakMap()),
  (nn = new WeakMap()),
  (rn = new WeakMap()),
  (Dn = new WeakMap()),
  (sn = new WeakMap()),
  (Ce = new WeakMap()),
  (an = new WeakMap()),
  (Nn = new WeakMap()),
  (On = new WeakMap()),
  (bt = new WeakMap()),
  (Tr = new WeakSet()),
  (Ts = function (e) {
    if (
      (te(this, Nn, !0, "f"),
      e instanceof Error && e.name === "AbortError" && (e = new B()),
      e instanceof B)
    )
      return te(this, On, !0, "f"), this._emit("abort", e);
    if (e instanceof C) return this._emit("error", e);
    if (e instanceof Error) {
      let t = new C(e.message);
      return (t.cause = e), this._emit("error", t);
    }
    return this._emit("error", new C(String(e)));
  });
function on(r) {
  return (r == null ? void 0 : r.$brand) === "auto-parseable-response-format";
}
function Ze(r) {
  return (r == null ? void 0 : r.$brand) === "auto-parseable-tool";
}
function Is(r, e) {
  return !e || !Ir(e)
    ? {
        ...r,
        choices: r.choices.map((t) => ({
          ...t,
          message: {
            ...t.message,
            parsed: null,
            ...(t.message.tool_calls
              ? { tool_calls: t.message.tool_calls }
              : void 0),
          },
        })),
      }
    : ln(r, e);
}
function ln(r, e) {
  let t = r.choices.map((n) => {
    var s, a;
    if (n.finish_reason === "length") throw new ht();
    if (n.finish_reason === "content_filter") throw new pt();
    return {
      ...n,
      message: {
        ...n.message,
        ...(n.message.tool_calls
          ? {
              tool_calls:
                (a =
                  (s = n.message.tool_calls) == null
                    ? void 0
                    : s.map((i) => ri(e, i))) != null
                  ? a
                  : void 0,
            }
          : void 0),
        parsed:
          n.message.content && !n.message.refusal
            ? ni(e, n.message.content)
            : null,
      },
    };
  });
  return { ...r, choices: t };
}
function ni(r, e) {
  var t, n;
  return ((t = r.response_format) == null ? void 0 : t.type) !== "json_schema"
    ? null
    : ((n = r.response_format) == null ? void 0 : n.type) === "json_schema"
      ? "$parseRaw" in r.response_format
        ? r.response_format.$parseRaw(e)
        : JSON.parse(e)
      : null;
}
function ri(r, e) {
  var n;
  let t =
    (n = r.tools) == null
      ? void 0
      : n.find((s) => {
          var a;
          return (
            ((a = s.function) == null ? void 0 : a.name) === e.function.name
          );
        });
  return {
    ...e,
    function: {
      ...e.function,
      parsed_arguments: Ze(t)
        ? t.$parseRaw(e.function.arguments)
        : t != null && t.function.strict
          ? JSON.parse(e.function.arguments)
          : null,
    },
  };
}
function Fs(r, e) {
  var n;
  if (!r) return !1;
  let t =
    (n = r.tools) == null
      ? void 0
      : n.find((s) => {
          var a;
          return (
            ((a = s.function) == null ? void 0 : a.name) === e.function.name
          );
        });
  return Ze(t) || (t == null ? void 0 : t.function.strict) || !1;
}
function Ir(r) {
  var e, t;
  return on(r.response_format)
    ? !0
    : (t =
          (e = r.tools) == null
            ? void 0
            : e.some(
                (n) =>
                  Ze(n) || (n.type === "function" && n.function.strict === !0),
              )) != null
      ? t
      : !1;
}
function vs(r) {
  for (let e of r != null ? r : []) {
    if (e.type !== "function")
      throw new C(
        `Currently only \`function\` tool types support auto-parsing; Received \`${e.type}\``,
      );
    if (e.function.strict !== !0)
      throw new C(
        `The \`${e.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`,
      );
  }
}
var J = function (r, e, t, n) {
    if (t === "a" && !n)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it",
      );
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
  },
  H,
  Fr,
  kn,
  vr,
  Rr,
  Mr,
  Ms,
  Dr,
  Rs = 10,
  Et = class extends Oe {
    constructor() {
      super(...arguments),
        H.add(this),
        (this._chatCompletions = []),
        (this.messages = []);
    }
    _addChatCompletion(e) {
      var n;
      this._chatCompletions.push(e), this._emit("chatCompletion", e);
      let t = (n = e.choices[0]) == null ? void 0 : n.message;
      return t && this._addMessage(t), e;
    }
    _addMessage(e, t = !0) {
      if (("content" in e || (e.content = null), this.messages.push(e), t)) {
        if ((this._emit("message", e), (Pr(e) || Sr(e)) && e.content))
          this._emit("functionCallResult", e.content);
        else if (Ne(e) && e.function_call)
          this._emit("functionCall", e.function_call);
        else if (Ne(e) && e.tool_calls)
          for (let n of e.tool_calls)
            n.type === "function" && this._emit("functionCall", n.function);
      }
    }
    async finalChatCompletion() {
      await this.done();
      let e = this._chatCompletions[this._chatCompletions.length - 1];
      if (!e) throw new C("stream ended without producing a ChatCompletion");
      return e;
    }
    async finalContent() {
      return await this.done(), J(this, H, "m", Fr).call(this);
    }
    async finalMessage() {
      return await this.done(), J(this, H, "m", kn).call(this);
    }
    async finalFunctionCall() {
      return await this.done(), J(this, H, "m", vr).call(this);
    }
    async finalFunctionCallResult() {
      return await this.done(), J(this, H, "m", Rr).call(this);
    }
    async totalUsage() {
      return await this.done(), J(this, H, "m", Mr).call(this);
    }
    allChatCompletions() {
      return [...this._chatCompletions];
    }
    _emitFinal() {
      let e = this._chatCompletions[this._chatCompletions.length - 1];
      e && this._emit("finalChatCompletion", e);
      let t = J(this, H, "m", kn).call(this);
      t && this._emit("finalMessage", t);
      let n = J(this, H, "m", Fr).call(this);
      n && this._emit("finalContent", n);
      let s = J(this, H, "m", vr).call(this);
      s && this._emit("finalFunctionCall", s);
      let a = J(this, H, "m", Rr).call(this);
      a != null && this._emit("finalFunctionCallResult", a),
        this._chatCompletions.some((i) => i.usage) &&
          this._emit("totalUsage", J(this, H, "m", Mr).call(this));
    }
    async _createChatCompletion(e, t, n) {
      let s = n == null ? void 0 : n.signal;
      s &&
        (s.aborted && this.controller.abort(),
        s.addEventListener("abort", () => this.controller.abort())),
        J(this, H, "m", Ms).call(this, t);
      let a = await e.chat.completions.create(
        { ...t, stream: !1 },
        { ...n, signal: this.controller.signal },
      );
      return this._connected(), this._addChatCompletion(ln(a, t));
    }
    async _runChatCompletion(e, t, n) {
      for (let s of t.messages) this._addMessage(s, !1);
      return await this._createChatCompletion(e, t, n);
    }
    async _runFunctions(e, t, n) {
      var y;
      let s = "function",
        { function_call: a = "auto", stream: i, ...o } = t,
        l = typeof a != "string" && (a == null ? void 0 : a.name),
        { maxChatCompletions: d = Rs } = n || {},
        f = {};
      for (let h of t.functions) f[h.name || h.function.name] = h;
      let m = t.functions.map((h) => ({
        name: h.name || h.function.name,
        parameters: h.parameters,
        description: h.description,
      }));
      for (let h of t.messages) this._addMessage(h, !1);
      for (let h = 0; h < d; ++h) {
        let x =
          (y = (
            await this._createChatCompletion(
              e,
              {
                ...o,
                function_call: a,
                functions: m,
                messages: [...this.messages],
              },
              n,
            )
          ).choices[0]) == null
            ? void 0
            : y.message;
        if (!x) throw new C("missing message in ChatCompletion response");
        if (!x.function_call) return;
        let { name: u, arguments: p } = x.function_call,
          w = f[u];
        if (w) {
          if (l && l !== u) {
            let I = `Invalid function_call: ${JSON.stringify(u)}. ${JSON.stringify(l)} requested. Please try again`;
            this._addMessage({ role: s, name: u, content: I });
            continue;
          }
        } else {
          let I = `Invalid function_call: ${JSON.stringify(u)}. Available options are: ${m.map((R) => JSON.stringify(R.name)).join(", ")}. Please try again`;
          this._addMessage({ role: s, name: u, content: I });
          continue;
        }
        let g;
        try {
          g = Ar(w) ? await w.parse(p) : p;
        } catch (I) {
          this._addMessage({
            role: s,
            name: u,
            content: I instanceof Error ? I.message : String(I),
          });
          continue;
        }
        let A = await w.function(g, this),
          E = J(this, H, "m", Dr).call(this, A);
        if ((this._addMessage({ role: s, name: u, content: E }), l)) return;
      }
    }
    async _runTools(e, t, n) {
      var h, b, x;
      let s = "tool",
        { tool_choice: a = "auto", stream: i, ...o } = t,
        l =
          typeof a != "string" &&
          ((h = a == null ? void 0 : a.function) == null ? void 0 : h.name),
        { maxChatCompletions: d = Rs } = n || {},
        f = t.tools.map((u) => {
          if (Ze(u)) {
            if (!u.$callback)
              throw new C(
                "Tool given to `.runTools()` that does not have an associated function",
              );
            return {
              type: "function",
              function: {
                function: u.$callback,
                name: u.function.name,
                description: u.function.description || "",
                parameters: u.function.parameters,
                parse: u.$parseRaw,
                strict: !0,
              },
            };
          }
          return u;
        }),
        m = {};
      for (let u of f)
        u.type === "function" &&
          (m[u.function.name || u.function.function.name] = u.function);
      let y =
        "tools" in t
          ? f.map((u) =>
              u.type === "function"
                ? {
                    type: "function",
                    function: {
                      name: u.function.name || u.function.function.name,
                      parameters: u.function.parameters,
                      description: u.function.description,
                      strict: u.function.strict,
                    },
                  }
                : u,
            )
          : void 0;
      for (let u of t.messages) this._addMessage(u, !1);
      for (let u = 0; u < d; ++u) {
        let w =
          (b = (
            await this._createChatCompletion(
              e,
              { ...o, tool_choice: a, tools: y, messages: [...this.messages] },
              n,
            )
          ).choices[0]) == null
            ? void 0
            : b.message;
        if (!w) throw new C("missing message in ChatCompletion response");
        if (!((x = w.tool_calls) != null && x.length)) return;
        for (let g of w.tool_calls) {
          if (g.type !== "function") continue;
          let A = g.id,
            { name: E, arguments: I } = g.function,
            R = m[E];
          if (R) {
            if (l && l !== E) {
              let $ = `Invalid tool_call: ${JSON.stringify(E)}. ${JSON.stringify(l)} requested. Please try again`;
              this._addMessage({ role: s, tool_call_id: A, content: $ });
              continue;
            }
          } else {
            let $ = `Invalid tool_call: ${JSON.stringify(E)}. Available options are: ${Object.keys(
              m,
            )
              .map((N) => JSON.stringify(N))
              .join(", ")}. Please try again`;
            this._addMessage({ role: s, tool_call_id: A, content: $ });
            continue;
          }
          let D;
          try {
            D = Ar(R) ? await R.parse(I) : I;
          } catch ($) {
            let N = $ instanceof Error ? $.message : String($);
            this._addMessage({ role: s, tool_call_id: A, content: N });
            continue;
          }
          let v = await R.function(D, this),
            M = J(this, H, "m", Dr).call(this, v);
          if ((this._addMessage({ role: s, tool_call_id: A, content: M }), l))
            return;
        }
      }
    }
  };
(H = new WeakSet()),
  (Fr = function () {
    var e;
    return (e = J(this, H, "m", kn).call(this).content) != null ? e : null;
  }),
  (kn = function () {
    var t, n;
    let e = this.messages.length;
    for (; e-- > 0; ) {
      let s = this.messages[e];
      if (Ne(s)) {
        let { function_call: a, ...i } = s,
          o = {
            ...i,
            content: (t = s.content) != null ? t : null,
            refusal: (n = s.refusal) != null ? n : null,
          };
        return a && (o.function_call = a), o;
      }
    }
    throw new C(
      "stream ended without producing a ChatCompletionMessage with role=assistant",
    );
  }),
  (vr = function () {
    var e, t;
    for (let n = this.messages.length - 1; n >= 0; n--) {
      let s = this.messages[n];
      if (Ne(s) && s != null && s.function_call) return s.function_call;
      if (Ne(s) && (e = s == null ? void 0 : s.tool_calls) != null && e.length)
        return (t = s.tool_calls.at(-1)) == null ? void 0 : t.function;
    }
  }),
  (Rr = function () {
    for (let e = this.messages.length - 1; e >= 0; e--) {
      let t = this.messages[e];
      if (
        (Pr(t) && t.content != null) ||
        (Sr(t) &&
          t.content != null &&
          typeof t.content == "string" &&
          this.messages.some((n) => {
            var s;
            return (
              n.role === "assistant" &&
              ((s = n.tool_calls) == null
                ? void 0
                : s.some(
                    (a) => a.type === "function" && a.id === t.tool_call_id,
                  ))
            );
          }))
      )
        return t.content;
    }
  }),
  (Mr = function () {
    let e = { completion_tokens: 0, prompt_tokens: 0, total_tokens: 0 };
    for (let { usage: t } of this._chatCompletions)
      t &&
        ((e.completion_tokens += t.completion_tokens),
        (e.prompt_tokens += t.prompt_tokens),
        (e.total_tokens += t.total_tokens));
    return e;
  }),
  (Ms = function (e) {
    if (e.n != null && e.n > 1)
      throw new C(
        "ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.",
      );
  }),
  (Dr = function (e) {
    return typeof e == "string"
      ? e
      : e === void 0
        ? "undefined"
        : JSON.stringify(e);
  });
var cn = class r extends Et {
  static runFunctions(e, t, n) {
    let s = new r(),
      a = {
        ...n,
        headers: {
          ...(n == null ? void 0 : n.headers),
          "X-Stainless-Helper-Method": "runFunctions",
        },
      };
    return s._run(() => s._runFunctions(e, t, a)), s;
  }
  static runTools(e, t, n) {
    let s = new r(),
      a = {
        ...n,
        headers: {
          ...(n == null ? void 0 : n.headers),
          "X-Stainless-Helper-Method": "runTools",
        },
      };
    return s._run(() => s._runTools(e, t, a)), s;
  }
  _addMessage(e, t = !0) {
    super._addMessage(e, t),
      Ne(e) && e.content && this._emit("content", e.content);
  }
};
var q = {
    STR: 1,
    NUM: 2,
    ARR: 4,
    OBJ: 8,
    NULL: 16,
    BOOL: 32,
    NAN: 64,
    INFINITY: 128,
    MINUS_INFINITY: 256,
    INF: 384,
    SPECIAL: 496,
    ATOM: 499,
    COLLECTION: 12,
    ALL: 511,
  },
  Nr = class extends Error {},
  Or = class extends Error {};
function si(r, e = q.ALL) {
  if (typeof r != "string")
    throw new TypeError(`expecting str, got ${typeof r}`);
  if (!r.trim()) throw new Error(`${r} is empty`);
  return ai(r.trim(), e);
}
var ai = (r, e) => {
    let t = r.length,
      n = 0,
      s = (y) => {
        throw new Nr(`${y} at position ${n}`);
      },
      a = (y) => {
        throw new Or(`${y} at position ${n}`);
      },
      i = () => (
        m(),
        n >= t && s("Unexpected end of input"),
        r[n] === '"'
          ? o()
          : r[n] === "{"
            ? l()
            : r[n] === "["
              ? d()
              : r.substring(n, n + 4) === "null" ||
                  (q.NULL & e && t - n < 4 && "null".startsWith(r.substring(n)))
                ? ((n += 4), null)
                : r.substring(n, n + 4) === "true" ||
                    (q.BOOL & e &&
                      t - n < 4 &&
                      "true".startsWith(r.substring(n)))
                  ? ((n += 4), !0)
                  : r.substring(n, n + 5) === "false" ||
                      (q.BOOL & e &&
                        t - n < 5 &&
                        "false".startsWith(r.substring(n)))
                    ? ((n += 5), !1)
                    : r.substring(n, n + 8) === "Infinity" ||
                        (q.INFINITY & e &&
                          t - n < 8 &&
                          "Infinity".startsWith(r.substring(n)))
                      ? ((n += 8), 1 / 0)
                      : r.substring(n, n + 9) === "-Infinity" ||
                          (q.MINUS_INFINITY & e &&
                            1 < t - n &&
                            t - n < 9 &&
                            "-Infinity".startsWith(r.substring(n)))
                        ? ((n += 9), -1 / 0)
                        : r.substring(n, n + 3) === "NaN" ||
                            (q.NAN & e &&
                              t - n < 3 &&
                              "NaN".startsWith(r.substring(n)))
                          ? ((n += 3), NaN)
                          : f()
      ),
      o = () => {
        let y = n,
          h = !1;
        for (n++; n < t && (r[n] !== '"' || (h && r[n - 1] === "\\")); )
          (h = r[n] === "\\" ? !h : !1), n++;
        if (r.charAt(n) == '"')
          try {
            return JSON.parse(r.substring(y, ++n - Number(h)));
          } catch (b) {
            a(String(b));
          }
        else if (q.STR & e)
          try {
            return JSON.parse(r.substring(y, n - Number(h)) + '"');
          } catch (b) {
            return JSON.parse(r.substring(y, r.lastIndexOf("\\")) + '"');
          }
        s("Unterminated string literal");
      },
      l = () => {
        n++, m();
        let y = {};
        try {
          for (; r[n] !== "}"; ) {
            if ((m(), n >= t && q.OBJ & e)) return y;
            let h = o();
            m(), n++;
            try {
              let b = i();
              Object.defineProperty(y, h, {
                value: b,
                writable: !0,
                enumerable: !0,
                configurable: !0,
              });
            } catch (b) {
              if (q.OBJ & e) return y;
              throw b;
            }
            m(), r[n] === "," && n++;
          }
        } catch (h) {
          if (q.OBJ & e) return y;
          s("Expected '}' at end of object");
        }
        return n++, y;
      },
      d = () => {
        n++;
        let y = [];
        try {
          for (; r[n] !== "]"; ) y.push(i()), m(), r[n] === "," && n++;
        } catch (h) {
          if (q.ARR & e) return y;
          s("Expected ']' at end of array");
        }
        return n++, y;
      },
      f = () => {
        if (n === 0) {
          r === "-" && q.NUM & e && s("Not sure what '-' is");
          try {
            return JSON.parse(r);
          } catch (h) {
            if (q.NUM & e)
              try {
                return r[r.length - 1] === "."
                  ? JSON.parse(r.substring(0, r.lastIndexOf(".")))
                  : JSON.parse(r.substring(0, r.lastIndexOf("e")));
              } catch (b) {}
            a(String(h));
          }
        }
        let y = n;
        for (r[n] === "-" && n++; r[n] && !",]}".includes(r[n]); ) n++;
        n == t && !(q.NUM & e) && s("Unterminated number literal");
        try {
          return JSON.parse(r.substring(y, n));
        } catch (h) {
          r.substring(y, n) === "-" && q.NUM & e && s("Not sure what '-' is");
          try {
            return JSON.parse(r.substring(y, r.lastIndexOf("e")));
          } catch (b) {
            a(String(b));
          }
        }
      },
      m = () => {
        for (
          ;
          n < t &&
          ` 
\r	`.includes(r[n]);

        )
          n++;
      };
    return i();
  },
  kr = (r) => si(r, q.ALL ^ q.NUM);
var Ct = function (r, e, t, n, s) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !s)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !s : !e.has(r))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it",
      );
    return n === "a" ? s.call(r, t) : s ? (s.value = t) : e.set(r, t), t;
  },
  k = function (r, e, t, n) {
    if (t === "a" && !n)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it",
      );
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
  },
  V,
  Ae,
  At,
  ke,
  $r,
  $n,
  Lr,
  Br,
  Ur,
  Ln,
  jr,
  Ds,
  Pt = class r extends Et {
    constructor(e) {
      super(),
        V.add(this),
        Ae.set(this, void 0),
        At.set(this, void 0),
        ke.set(this, void 0),
        Ct(this, Ae, e, "f"),
        Ct(this, At, [], "f");
    }
    get currentChatCompletionSnapshot() {
      return k(this, ke, "f");
    }
    static fromReadableStream(e) {
      let t = new r(null);
      return t._run(() => t._fromReadableStream(e)), t;
    }
    static createChatCompletion(e, t, n) {
      let s = new r(t);
      return (
        s._run(() =>
          s._runChatCompletion(
            e,
            { ...t, stream: !0 },
            {
              ...n,
              headers: {
                ...(n == null ? void 0 : n.headers),
                "X-Stainless-Helper-Method": "stream",
              },
            },
          ),
        ),
        s
      );
    }
    async _createChatCompletion(e, t, n) {
      var i;
      super._createChatCompletion;
      let s = n == null ? void 0 : n.signal;
      s &&
        (s.aborted && this.controller.abort(),
        s.addEventListener("abort", () => this.controller.abort())),
        k(this, V, "m", $r).call(this);
      let a = await e.chat.completions.create(
        { ...t, stream: !0 },
        { ...n, signal: this.controller.signal },
      );
      this._connected();
      for await (let o of a) k(this, V, "m", Lr).call(this, o);
      if ((i = a.controller.signal) != null && i.aborted) throw new B();
      return this._addChatCompletion(k(this, V, "m", Ln).call(this));
    }
    async _fromReadableStream(e, t) {
      var i;
      let n = t == null ? void 0 : t.signal;
      n &&
        (n.aborted && this.controller.abort(),
        n.addEventListener("abort", () => this.controller.abort())),
        k(this, V, "m", $r).call(this),
        this._connected();
      let s = ce.fromReadableStream(e, this.controller),
        a;
      for await (let o of s)
        a &&
          a !== o.id &&
          this._addChatCompletion(k(this, V, "m", Ln).call(this)),
          k(this, V, "m", Lr).call(this, o),
          (a = o.id);
      if ((i = s.controller.signal) != null && i.aborted) throw new B();
      return this._addChatCompletion(k(this, V, "m", Ln).call(this));
    }
    [((Ae = new WeakMap()),
    (At = new WeakMap()),
    (ke = new WeakMap()),
    (V = new WeakSet()),
    ($r = function () {
      this.ended || Ct(this, ke, void 0, "f");
    }),
    ($n = function (t) {
      let n = k(this, At, "f")[t.index];
      return (
        n ||
        ((n = {
          content_done: !1,
          refusal_done: !1,
          logprobs_content_done: !1,
          logprobs_refusal_done: !1,
          done_tool_calls: new Set(),
          current_tool_call_index: null,
        }),
        (k(this, At, "f")[t.index] = n),
        n)
      );
    }),
    (Lr = function (t) {
      var s, a, i, o, l, d, f, m, y, h, b, x, u, p, w, g, A, E, I, R;
      if (this.ended) return;
      let n = k(this, V, "m", Ds).call(this, t);
      this._emit("chunk", t, n);
      for (let D of t.choices) {
        let v = n.choices[D.index];
        D.delta.content != null &&
          ((s = v.message) == null ? void 0 : s.role) === "assistant" &&
          (a = v.message) != null &&
          a.content &&
          (this._emit("content", D.delta.content, v.message.content),
          this._emit("content.delta", {
            delta: D.delta.content,
            snapshot: v.message.content,
            parsed: v.message.parsed,
          })),
          D.delta.refusal != null &&
            ((i = v.message) == null ? void 0 : i.role) === "assistant" &&
            (o = v.message) != null &&
            o.refusal &&
            this._emit("refusal.delta", {
              delta: D.delta.refusal,
              snapshot: v.message.refusal,
            }),
          ((l = D.logprobs) == null ? void 0 : l.content) != null &&
            ((d = v.message) == null ? void 0 : d.role) === "assistant" &&
            this._emit("logprobs.content.delta", {
              content: (f = D.logprobs) == null ? void 0 : f.content,
              snapshot:
                (y = (m = v.logprobs) == null ? void 0 : m.content) != null
                  ? y
                  : [],
            }),
          ((h = D.logprobs) == null ? void 0 : h.refusal) != null &&
            ((b = v.message) == null ? void 0 : b.role) === "assistant" &&
            this._emit("logprobs.refusal.delta", {
              refusal: (x = D.logprobs) == null ? void 0 : x.refusal,
              snapshot:
                (p = (u = v.logprobs) == null ? void 0 : u.refusal) != null
                  ? p
                  : [],
            });
        let M = k(this, V, "m", $n).call(this, v);
        v.finish_reason &&
          (k(this, V, "m", Ur).call(this, v),
          M.current_tool_call_index != null &&
            k(this, V, "m", Br).call(this, v, M.current_tool_call_index));
        for (let $ of (w = D.delta.tool_calls) != null ? w : [])
          M.current_tool_call_index !== $.index &&
            (k(this, V, "m", Ur).call(this, v),
            M.current_tool_call_index != null &&
              k(this, V, "m", Br).call(this, v, M.current_tool_call_index)),
            (M.current_tool_call_index = $.index);
        for (let $ of (g = D.delta.tool_calls) != null ? g : []) {
          let N = (A = v.message.tool_calls) == null ? void 0 : A[$.index];
          N != null &&
            N.type &&
            ((N == null ? void 0 : N.type) === "function"
              ? this._emit("tool_calls.function.arguments.delta", {
                  name: (E = N.function) == null ? void 0 : E.name,
                  index: $.index,
                  arguments: N.function.arguments,
                  parsed_arguments: N.function.parsed_arguments,
                  arguments_delta:
                    (R = (I = $.function) == null ? void 0 : I.arguments) !=
                    null
                      ? R
                      : "",
                })
              : (N == null || N.type, void 0));
        }
      }
    }),
    (Br = function (t, n) {
      var i, o, l;
      if (k(this, V, "m", $n).call(this, t).done_tool_calls.has(n)) return;
      let a = (i = t.message.tool_calls) == null ? void 0 : i[n];
      if (!a) throw new Error("no tool call snapshot");
      if (!a.type) throw new Error("tool call snapshot missing `type`");
      if (a.type === "function") {
        let d =
          (l = (o = k(this, Ae, "f")) == null ? void 0 : o.tools) == null
            ? void 0
            : l.find(
                (f) =>
                  f.type === "function" && f.function.name === a.function.name,
              );
        this._emit("tool_calls.function.arguments.done", {
          name: a.function.name,
          index: n,
          arguments: a.function.arguments,
          parsed_arguments: Ze(d)
            ? d.$parseRaw(a.function.arguments)
            : d != null && d.function.strict
              ? JSON.parse(a.function.arguments)
              : null,
        });
      } else a.type;
    }),
    (Ur = function (t) {
      var s, a;
      let n = k(this, V, "m", $n).call(this, t);
      if (t.message.content && !n.content_done) {
        n.content_done = !0;
        let i = k(this, V, "m", jr).call(this);
        this._emit("content.done", {
          content: t.message.content,
          parsed: i ? i.$parseRaw(t.message.content) : null,
        });
      }
      t.message.refusal &&
        !n.refusal_done &&
        ((n.refusal_done = !0),
        this._emit("refusal.done", { refusal: t.message.refusal })),
        (s = t.logprobs) != null &&
          s.content &&
          !n.logprobs_content_done &&
          ((n.logprobs_content_done = !0),
          this._emit("logprobs.content.done", { content: t.logprobs.content })),
        (a = t.logprobs) != null &&
          a.refusal &&
          !n.logprobs_refusal_done &&
          ((n.logprobs_refusal_done = !0),
          this._emit("logprobs.refusal.done", { refusal: t.logprobs.refusal }));
    }),
    (Ln = function () {
      if (this.ended) throw new C("stream has ended, this shouldn't happen");
      let t = k(this, ke, "f");
      if (!t) throw new C("request ended without sending any chunks");
      return (
        Ct(this, ke, void 0, "f"),
        Ct(this, At, [], "f"),
        ii(t, k(this, Ae, "f"))
      );
    }),
    (jr = function () {
      var n;
      let t = (n = k(this, Ae, "f")) == null ? void 0 : n.response_format;
      return on(t) ? t : null;
    }),
    (Ds = function (t) {
      var f, m, y, h, b, x;
      var n, s, a, i;
      let o = k(this, ke, "f"),
        { choices: l, ...d } = t;
      o ? Object.assign(o, d) : (o = Ct(this, ke, { ...d, choices: [] }, "f"));
      for (let {
        delta: u,
        finish_reason: p,
        index: w,
        logprobs: g = null,
        ...A
      } of t.choices) {
        let E = o.choices[w];
        if (
          (E ||
            (E = o.choices[w] =
              { finish_reason: p, index: w, message: {}, logprobs: g, ...A }),
          g)
        )
          if (!E.logprobs) E.logprobs = Object.assign({}, g);
          else {
            let { content: N, refusal: Z, ...we } = g;
            Object.assign(E.logprobs, we),
              N &&
                ((f = (n = E.logprobs).content) != null || (n.content = []),
                E.logprobs.content.push(...N)),
              Z &&
                ((m = (s = E.logprobs).refusal) != null || (s.refusal = []),
                E.logprobs.refusal.push(...Z));
          }
        if (
          p &&
          ((E.finish_reason = p), k(this, Ae, "f") && Ir(k(this, Ae, "f")))
        ) {
          if (p === "length") throw new ht();
          if (p === "content_filter") throw new pt();
        }
        if ((Object.assign(E, A), !u)) continue;
        let {
          content: I,
          refusal: R,
          function_call: D,
          role: v,
          tool_calls: M,
          ...$
        } = u;
        if (
          (Object.assign(E.message, $),
          R && (E.message.refusal = (E.message.refusal || "") + R),
          v && (E.message.role = v),
          D &&
            (E.message.function_call
              ? (D.name && (E.message.function_call.name = D.name),
                D.arguments &&
                  ((y = (a = E.message.function_call).arguments) != null ||
                    (a.arguments = ""),
                  (E.message.function_call.arguments += D.arguments)))
              : (E.message.function_call = D)),
          I &&
            ((E.message.content = (E.message.content || "") + I),
            !E.message.refusal &&
              k(this, V, "m", jr).call(this) &&
              (E.message.parsed = kr(E.message.content))),
          M)
        ) {
          E.message.tool_calls || (E.message.tool_calls = []);
          for (let { index: N, id: Z, type: we, function: X, ...la } of M) {
            let ie =
              (h = (i = E.message.tool_calls)[N]) != null ? h : (i[N] = {});
            Object.assign(ie, la),
              Z && (ie.id = Z),
              we && (ie.type = we),
              X &&
                ((x = ie.function) != null ||
                  (ie.function = {
                    name: (b = X.name) != null ? b : "",
                    arguments: "",
                  })),
              X != null && X.name && (ie.function.name = X.name),
              X != null &&
                X.arguments &&
                ((ie.function.arguments += X.arguments),
                Fs(k(this, Ae, "f"), ie) &&
                  (ie.function.parsed_arguments = kr(ie.function.arguments)));
          }
        }
      }
      return o;
    }),
    Symbol.asyncIterator)]() {
      let e = [],
        t = [],
        n = !1;
      return (
        this.on("chunk", (s) => {
          let a = t.shift();
          a ? a.resolve(s) : e.push(s);
        }),
        this.on("end", () => {
          n = !0;
          for (let s of t) s.resolve(void 0);
          t.length = 0;
        }),
        this.on("abort", (s) => {
          n = !0;
          for (let a of t) a.reject(s);
          t.length = 0;
        }),
        this.on("error", (s) => {
          n = !0;
          for (let a of t) a.reject(s);
          t.length = 0;
        }),
        {
          next: async () =>
            e.length
              ? { value: e.shift(), done: !1 }
              : n
                ? { value: void 0, done: !0 }
                : new Promise((a, i) => t.push({ resolve: a, reject: i })).then(
                    (a) =>
                      a ? { value: a, done: !1 } : { value: void 0, done: !0 },
                  ),
          return: async () => (this.abort(), { value: void 0, done: !0 }),
        }
      );
    }
    toReadableStream() {
      return new ce(
        this[Symbol.asyncIterator].bind(this),
        this.controller,
      ).toReadableStream();
    }
  };
function ii(r, e) {
  let {
      id: t,
      choices: n,
      created: s,
      model: a,
      system_fingerprint: i,
      ...o
    } = r,
    l = {
      ...o,
      id: t,
      choices: n.map(
        ({ message: d, finish_reason: f, index: m, logprobs: y, ...h }) => {
          var g, A, E;
          if (!f) throw new C(`missing finish_reason for choice ${m}`);
          let { content: b = null, function_call: x, tool_calls: u, ...p } = d,
            w = d.role;
          if (!w) throw new C(`missing role for choice ${m}`);
          if (x) {
            let { arguments: I, name: R } = x;
            if (I == null)
              throw new C(`missing function_call.arguments for choice ${m}`);
            if (!R) throw new C(`missing function_call.name for choice ${m}`);
            return {
              ...h,
              message: {
                content: b,
                function_call: { arguments: I, name: R },
                role: w,
                refusal: (g = d.refusal) != null ? g : null,
              },
              finish_reason: f,
              index: m,
              logprobs: y,
            };
          }
          return u
            ? {
                ...h,
                index: m,
                finish_reason: f,
                logprobs: y,
                message: {
                  ...p,
                  role: w,
                  content: b,
                  refusal: (A = d.refusal) != null ? A : null,
                  tool_calls: u.map((I, R) => {
                    let { function: D, type: v, id: M, ...$ } = I,
                      { arguments: N, name: Z, ...we } = D || {};
                    if (M == null)
                      throw new C(`missing choices[${m}].tool_calls[${R}].id
${Bn(r)}`);
                    if (v == null)
                      throw new C(`missing choices[${m}].tool_calls[${R}].type
${Bn(r)}`);
                    if (Z == null)
                      throw new C(`missing choices[${m}].tool_calls[${R}].function.name
${Bn(r)}`);
                    if (N == null)
                      throw new C(`missing choices[${m}].tool_calls[${R}].function.arguments
${Bn(r)}`);
                    return {
                      ...$,
                      id: M,
                      type: v,
                      function: { ...we, name: Z, arguments: N },
                    };
                  }),
                },
              }
            : {
                ...h,
                message: {
                  ...p,
                  content: b,
                  role: w,
                  refusal: (E = d.refusal) != null ? E : null,
                },
                finish_reason: f,
                index: m,
                logprobs: y,
              };
        },
      ),
      created: s,
      model: a,
      object: "chat.completion",
      ...(i ? { system_fingerprint: i } : {}),
    };
  return Is(l, e);
}
function Bn(r) {
  return JSON.stringify(r);
}
var un = class r extends Pt {
  static fromReadableStream(e) {
    let t = new r(null);
    return t._run(() => t._fromReadableStream(e)), t;
  }
  static runFunctions(e, t, n) {
    let s = new r(null),
      a = {
        ...n,
        headers: {
          ...(n == null ? void 0 : n.headers),
          "X-Stainless-Helper-Method": "runFunctions",
        },
      };
    return s._run(() => s._runFunctions(e, t, a)), s;
  }
  static runTools(e, t, n) {
    let s = new r(t),
      a = {
        ...n,
        headers: {
          ...(n == null ? void 0 : n.headers),
          "X-Stainless-Helper-Method": "runTools",
        },
      };
    return s._run(() => s._runTools(e, t, a)), s;
  }
};
var dn = class extends _ {
  parse(e, t) {
    return (
      vs(e.tools),
      this._client.chat.completions
        .create(e, {
          ...t,
          headers: {
            ...(t == null ? void 0 : t.headers),
            "X-Stainless-Helper-Method": "beta.chat.completions.parse",
          },
        })
        ._thenUnwrap((n) => ln(n, e))
    );
  }
  runFunctions(e, t) {
    return e.stream
      ? un.runFunctions(this._client, e, t)
      : cn.runFunctions(this._client, e, t);
  }
  runTools(e, t) {
    return e.stream
      ? un.runTools(this._client, e, t)
      : cn.runTools(this._client, e, t);
  }
  stream(e, t) {
    return Pt.createChatCompletion(this._client, e, t);
  }
};
var St = class extends _ {
  constructor() {
    super(...arguments), (this.completions = new dn(this._client));
  }
};
(function (r) {
  r.Completions = dn;
})(St || (St = {}));
var Tt = class extends _ {
  create(e, t) {
    return this._client.post("/realtime/sessions", {
      body: e,
      ...t,
      headers: {
        "OpenAI-Beta": "assistants=v2",
        ...(t == null ? void 0 : t.headers),
      },
    });
  }
};
var It = class extends _ {
  create(e, t) {
    return this._client.post("/realtime/transcription_sessions", {
      body: e,
      ...t,
      headers: {
        "OpenAI-Beta": "assistants=v2",
        ...(t == null ? void 0 : t.headers),
      },
    });
  }
};
var $e = class extends _ {
  constructor() {
    super(...arguments),
      (this.sessions = new Tt(this._client)),
      (this.transcriptionSessions = new It(this._client));
  }
};
$e.Sessions = Tt;
$e.TranscriptionSessions = It;
var P = function (r, e, t, n) {
    if (t === "a" && !n)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it",
      );
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
  },
  G = function (r, e, t, n, s) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !s)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !s : !e.has(r))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it",
      );
    return n === "a" ? s.call(r, t) : s ? (s.value = t) : e.set(r, t), t;
  },
  W,
  Vr,
  de,
  Un,
  ne,
  tt,
  Ft,
  et,
  qn,
  Y,
  jn,
  Vn,
  hn,
  mn,
  fn,
  Ns,
  Os,
  ks,
  $s,
  Ls,
  Bs,
  Us,
  me = class r extends Oe {
    constructor() {
      super(...arguments),
        W.add(this),
        Vr.set(this, []),
        de.set(this, {}),
        Un.set(this, {}),
        ne.set(this, void 0),
        tt.set(this, void 0),
        Ft.set(this, void 0),
        et.set(this, void 0),
        qn.set(this, void 0),
        Y.set(this, void 0),
        jn.set(this, void 0),
        Vn.set(this, void 0),
        hn.set(this, void 0);
    }
    [((Vr = new WeakMap()),
    (de = new WeakMap()),
    (Un = new WeakMap()),
    (ne = new WeakMap()),
    (tt = new WeakMap()),
    (Ft = new WeakMap()),
    (et = new WeakMap()),
    (qn = new WeakMap()),
    (Y = new WeakMap()),
    (jn = new WeakMap()),
    (Vn = new WeakMap()),
    (hn = new WeakMap()),
    (W = new WeakSet()),
    Symbol.asyncIterator)]() {
      let e = [],
        t = [],
        n = !1;
      return (
        this.on("event", (s) => {
          let a = t.shift();
          a ? a.resolve(s) : e.push(s);
        }),
        this.on("end", () => {
          n = !0;
          for (let s of t) s.resolve(void 0);
          t.length = 0;
        }),
        this.on("abort", (s) => {
          n = !0;
          for (let a of t) a.reject(s);
          t.length = 0;
        }),
        this.on("error", (s) => {
          n = !0;
          for (let a of t) a.reject(s);
          t.length = 0;
        }),
        {
          next: async () =>
            e.length
              ? { value: e.shift(), done: !1 }
              : n
                ? { value: void 0, done: !0 }
                : new Promise((a, i) => t.push({ resolve: a, reject: i })).then(
                    (a) =>
                      a ? { value: a, done: !1 } : { value: void 0, done: !0 },
                  ),
          return: async () => (this.abort(), { value: void 0, done: !0 }),
        }
      );
    }
    static fromReadableStream(e) {
      let t = new r();
      return t._run(() => t._fromReadableStream(e)), t;
    }
    async _fromReadableStream(e, t) {
      var a;
      let n = t == null ? void 0 : t.signal;
      n &&
        (n.aborted && this.controller.abort(),
        n.addEventListener("abort", () => this.controller.abort())),
        this._connected();
      let s = ce.fromReadableStream(e, this.controller);
      for await (let i of s) P(this, W, "m", mn).call(this, i);
      if ((a = s.controller.signal) != null && a.aborted) throw new B();
      return this._addRun(P(this, W, "m", fn).call(this));
    }
    toReadableStream() {
      return new ce(
        this[Symbol.asyncIterator].bind(this),
        this.controller,
      ).toReadableStream();
    }
    static createToolAssistantStream(e, t, n, s, a) {
      let i = new r();
      return (
        i._run(() =>
          i._runToolAssistantStream(e, t, n, s, {
            ...a,
            headers: {
              ...(a == null ? void 0 : a.headers),
              "X-Stainless-Helper-Method": "stream",
            },
          }),
        ),
        i
      );
    }
    async _createToolAssistantStream(e, t, n, s, a) {
      var d;
      let i = a == null ? void 0 : a.signal;
      i &&
        (i.aborted && this.controller.abort(),
        i.addEventListener("abort", () => this.controller.abort()));
      let o = { ...s, stream: !0 },
        l = await e.submitToolOutputs(t, n, o, {
          ...a,
          signal: this.controller.signal,
        });
      this._connected();
      for await (let f of l) P(this, W, "m", mn).call(this, f);
      if ((d = l.controller.signal) != null && d.aborted) throw new B();
      return this._addRun(P(this, W, "m", fn).call(this));
    }
    static createThreadAssistantStream(e, t, n) {
      let s = new r();
      return (
        s._run(() =>
          s._threadAssistantStream(e, t, {
            ...n,
            headers: {
              ...(n == null ? void 0 : n.headers),
              "X-Stainless-Helper-Method": "stream",
            },
          }),
        ),
        s
      );
    }
    static createAssistantStream(e, t, n, s) {
      let a = new r();
      return (
        a._run(() =>
          a._runAssistantStream(e, t, n, {
            ...s,
            headers: {
              ...(s == null ? void 0 : s.headers),
              "X-Stainless-Helper-Method": "stream",
            },
          }),
        ),
        a
      );
    }
    currentEvent() {
      return P(this, jn, "f");
    }
    currentRun() {
      return P(this, Vn, "f");
    }
    currentMessageSnapshot() {
      return P(this, ne, "f");
    }
    currentRunStepSnapshot() {
      return P(this, hn, "f");
    }
    async finalRunSteps() {
      return await this.done(), Object.values(P(this, de, "f"));
    }
    async finalMessages() {
      return await this.done(), Object.values(P(this, Un, "f"));
    }
    async finalRun() {
      if ((await this.done(), !P(this, tt, "f")))
        throw Error("Final run was not received.");
      return P(this, tt, "f");
    }
    async _createThreadAssistantStream(e, t, n) {
      var o;
      let s = n == null ? void 0 : n.signal;
      s &&
        (s.aborted && this.controller.abort(),
        s.addEventListener("abort", () => this.controller.abort()));
      let a = { ...t, stream: !0 },
        i = await e.createAndRun(a, { ...n, signal: this.controller.signal });
      this._connected();
      for await (let l of i) P(this, W, "m", mn).call(this, l);
      if ((o = i.controller.signal) != null && o.aborted) throw new B();
      return this._addRun(P(this, W, "m", fn).call(this));
    }
    async _createAssistantStream(e, t, n, s) {
      var l;
      let a = s == null ? void 0 : s.signal;
      a &&
        (a.aborted && this.controller.abort(),
        a.addEventListener("abort", () => this.controller.abort()));
      let i = { ...n, stream: !0 },
        o = await e.create(t, i, { ...s, signal: this.controller.signal });
      this._connected();
      for await (let d of o) P(this, W, "m", mn).call(this, d);
      if ((l = o.controller.signal) != null && l.aborted) throw new B();
      return this._addRun(P(this, W, "m", fn).call(this));
    }
    static accumulateDelta(e, t) {
      for (let [n, s] of Object.entries(t)) {
        if (!e.hasOwnProperty(n)) {
          e[n] = s;
          continue;
        }
        let a = e[n];
        if (a == null) {
          e[n] = s;
          continue;
        }
        if (n === "index" || n === "type") {
          e[n] = s;
          continue;
        }
        if (typeof a == "string" && typeof s == "string") a += s;
        else if (typeof a == "number" && typeof s == "number") a += s;
        else if (tn(a) && tn(s)) a = this.accumulateDelta(a, s);
        else if (Array.isArray(a) && Array.isArray(s)) {
          if (a.every((i) => typeof i == "string" || typeof i == "number")) {
            a.push(...s);
            continue;
          }
          for (let i of s) {
            if (!tn(i))
              throw new Error(
                `Expected array delta entry to be an object but got: ${i}`,
              );
            let o = i.index;
            if (o == null)
              throw (
                (console.error(i),
                new Error(
                  "Expected array delta entry to have an `index` property",
                ))
              );
            if (typeof o != "number")
              throw new Error(
                `Expected array delta entry \`index\` property to be a number but got ${o}`,
              );
            let l = a[o];
            l == null ? a.push(i) : (a[o] = this.accumulateDelta(l, i));
          }
          continue;
        } else
          throw Error(
            `Unhandled record type: ${n}, deltaValue: ${s}, accValue: ${a}`,
          );
        e[n] = a;
      }
      return e;
    }
    _addRun(e) {
      return e;
    }
    async _threadAssistantStream(e, t, n) {
      return await this._createThreadAssistantStream(t, e, n);
    }
    async _runAssistantStream(e, t, n, s) {
      return await this._createAssistantStream(t, e, n, s);
    }
    async _runToolAssistantStream(e, t, n, s, a) {
      return await this._createToolAssistantStream(n, e, t, s, a);
    }
  };
(mn = function (e) {
  if (!this.ended)
    switch ((G(this, jn, e, "f"), P(this, W, "m", ks).call(this, e), e.event)) {
      case "thread.created":
        break;
      case "thread.run.created":
      case "thread.run.queued":
      case "thread.run.in_progress":
      case "thread.run.requires_action":
      case "thread.run.completed":
      case "thread.run.incomplete":
      case "thread.run.failed":
      case "thread.run.cancelling":
      case "thread.run.cancelled":
      case "thread.run.expired":
        P(this, W, "m", Us).call(this, e);
        break;
      case "thread.run.step.created":
      case "thread.run.step.in_progress":
      case "thread.run.step.delta":
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        P(this, W, "m", Os).call(this, e);
        break;
      case "thread.message.created":
      case "thread.message.in_progress":
      case "thread.message.delta":
      case "thread.message.completed":
      case "thread.message.incomplete":
        P(this, W, "m", Ns).call(this, e);
        break;
      case "error":
        throw new Error(
          "Encountered an error event in event processing - errors should be processed earlier",
        );
      default:
    }
}),
  (fn = function () {
    if (this.ended) throw new C("stream has ended, this shouldn't happen");
    if (!P(this, tt, "f")) throw Error("Final run has not been received");
    return P(this, tt, "f");
  }),
  (Ns = function (e) {
    let [t, n] = P(this, W, "m", Ls).call(this, e, P(this, ne, "f"));
    G(this, ne, t, "f"), (P(this, Un, "f")[t.id] = t);
    for (let s of n) {
      let a = t.content[s.index];
      (a == null ? void 0 : a.type) == "text" &&
        this._emit("textCreated", a.text);
    }
    switch (e.event) {
      case "thread.message.created":
        this._emit("messageCreated", e.data);
        break;
      case "thread.message.in_progress":
        break;
      case "thread.message.delta":
        if ((this._emit("messageDelta", e.data.delta, t), e.data.delta.content))
          for (let s of e.data.delta.content) {
            if (s.type == "text" && s.text) {
              let a = s.text,
                i = t.content[s.index];
              if (i && i.type == "text") this._emit("textDelta", a, i.text);
              else
                throw Error(
                  "The snapshot associated with this text delta is not text or missing",
                );
            }
            if (s.index != P(this, Ft, "f")) {
              if (P(this, et, "f"))
                switch (P(this, et, "f").type) {
                  case "text":
                    this._emit(
                      "textDone",
                      P(this, et, "f").text,
                      P(this, ne, "f"),
                    );
                    break;
                  case "image_file":
                    this._emit(
                      "imageFileDone",
                      P(this, et, "f").image_file,
                      P(this, ne, "f"),
                    );
                    break;
                }
              G(this, Ft, s.index, "f");
            }
            G(this, et, t.content[s.index], "f");
          }
        break;
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (P(this, Ft, "f") !== void 0) {
          let s = e.data.content[P(this, Ft, "f")];
          if (s)
            switch (s.type) {
              case "image_file":
                this._emit("imageFileDone", s.image_file, P(this, ne, "f"));
                break;
              case "text":
                this._emit("textDone", s.text, P(this, ne, "f"));
                break;
            }
        }
        P(this, ne, "f") && this._emit("messageDone", e.data),
          G(this, ne, void 0, "f");
    }
  }),
  (Os = function (e) {
    let t = P(this, W, "m", $s).call(this, e);
    switch ((G(this, hn, t, "f"), e.event)) {
      case "thread.run.step.created":
        this._emit("runStepCreated", e.data);
        break;
      case "thread.run.step.delta":
        let n = e.data.delta;
        if (
          n.step_details &&
          n.step_details.type == "tool_calls" &&
          n.step_details.tool_calls &&
          t.step_details.type == "tool_calls"
        )
          for (let a of n.step_details.tool_calls)
            a.index == P(this, qn, "f")
              ? this._emit(
                  "toolCallDelta",
                  a,
                  t.step_details.tool_calls[a.index],
                )
              : (P(this, Y, "f") && this._emit("toolCallDone", P(this, Y, "f")),
                G(this, qn, a.index, "f"),
                G(this, Y, t.step_details.tool_calls[a.index], "f"),
                P(this, Y, "f") &&
                  this._emit("toolCallCreated", P(this, Y, "f")));
        this._emit("runStepDelta", e.data.delta, t);
        break;
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
        G(this, hn, void 0, "f"),
          e.data.step_details.type == "tool_calls" &&
            P(this, Y, "f") &&
            (this._emit("toolCallDone", P(this, Y, "f")),
            G(this, Y, void 0, "f")),
          this._emit("runStepDone", e.data, t);
        break;
      case "thread.run.step.in_progress":
        break;
    }
  }),
  (ks = function (e) {
    P(this, Vr, "f").push(e), this._emit("event", e);
  }),
  ($s = function (e) {
    switch (e.event) {
      case "thread.run.step.created":
        return (P(this, de, "f")[e.data.id] = e.data), e.data;
      case "thread.run.step.delta":
        let t = P(this, de, "f")[e.data.id];
        if (!t)
          throw Error("Received a RunStepDelta before creation of a snapshot");
        let n = e.data;
        if (n.delta) {
          let s = me.accumulateDelta(t, n.delta);
          P(this, de, "f")[e.data.id] = s;
        }
        return P(this, de, "f")[e.data.id];
      case "thread.run.step.completed":
      case "thread.run.step.failed":
      case "thread.run.step.cancelled":
      case "thread.run.step.expired":
      case "thread.run.step.in_progress":
        P(this, de, "f")[e.data.id] = e.data;
        break;
    }
    if (P(this, de, "f")[e.data.id]) return P(this, de, "f")[e.data.id];
    throw new Error("No snapshot available");
  }),
  (Ls = function (e, t) {
    let n = [];
    switch (e.event) {
      case "thread.message.created":
        return [e.data, n];
      case "thread.message.delta":
        if (!t)
          throw Error(
            "Received a delta with no existing snapshot (there should be one from message creation)",
          );
        let s = e.data;
        if (s.delta.content)
          for (let a of s.delta.content)
            if (a.index in t.content) {
              let i = t.content[a.index];
              t.content[a.index] = P(this, W, "m", Bs).call(this, a, i);
            } else (t.content[a.index] = a), n.push(a);
        return [t, n];
      case "thread.message.in_progress":
      case "thread.message.completed":
      case "thread.message.incomplete":
        if (t) return [t, n];
        throw Error("Received thread message event with no existing snapshot");
    }
    throw Error("Tried to accumulate a non-message event");
  }),
  (Bs = function (e, t) {
    return me.accumulateDelta(t, e);
  }),
  (Us = function (e) {
    switch ((G(this, Vn, e.data, "f"), e.event)) {
      case "thread.run.created":
        break;
      case "thread.run.queued":
        break;
      case "thread.run.in_progress":
        break;
      case "thread.run.requires_action":
      case "thread.run.cancelled":
      case "thread.run.failed":
      case "thread.run.completed":
      case "thread.run.expired":
        G(this, tt, e.data, "f"),
          P(this, Y, "f") &&
            (this._emit("toolCallDone", P(this, Y, "f")),
            G(this, Y, void 0, "f"));
        break;
      case "thread.run.cancelling":
        break;
    }
  });
var nt = class extends _ {
    create(e, t, n) {
      return this._client.post(`/threads/${e}/messages`, {
        body: t,
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
    retrieve(e, t, n) {
      return this._client.get(`/threads/${e}/messages/${t}`, {
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
    update(e, t, n, s) {
      return this._client.post(`/threads/${e}/messages/${t}`, {
        body: n,
        ...s,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(s == null ? void 0 : s.headers),
        },
      });
    }
    list(e, t = {}, n) {
      return F(t)
        ? this.list(e, {}, t)
        : this._client.getAPIList(`/threads/${e}/messages`, vt, {
            query: t,
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(n == null ? void 0 : n.headers),
            },
          });
    }
    del(e, t, n) {
      return this._client.delete(`/threads/${e}/messages/${t}`, {
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
  },
  vt = class extends O {};
nt.MessagesPage = vt;
var rt = class extends _ {
    retrieve(e, t, n, s = {}, a) {
      return F(s)
        ? this.retrieve(e, t, n, {}, s)
        : this._client.get(`/threads/${e}/runs/${t}/steps/${n}`, {
            query: s,
            ...a,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(a == null ? void 0 : a.headers),
            },
          });
    }
    list(e, t, n = {}, s) {
      return F(n)
        ? this.list(e, t, {}, n)
        : this._client.getAPIList(`/threads/${e}/runs/${t}/steps`, Rt, {
            query: n,
            ...s,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(s == null ? void 0 : s.headers),
            },
          });
    }
  },
  Rt = class extends O {};
rt.RunStepsPage = Rt;
var Pe = class extends _ {
    constructor() {
      super(...arguments), (this.steps = new rt(this._client));
    }
    create(e, t, n) {
      var i;
      let { include: s, ...a } = t;
      return this._client.post(`/threads/${e}/runs`, {
        query: { include: s },
        body: a,
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
        stream: (i = t.stream) != null ? i : !1,
      });
    }
    retrieve(e, t, n) {
      return this._client.get(`/threads/${e}/runs/${t}`, {
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
    update(e, t, n, s) {
      return this._client.post(`/threads/${e}/runs/${t}`, {
        body: n,
        ...s,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(s == null ? void 0 : s.headers),
        },
      });
    }
    list(e, t = {}, n) {
      return F(t)
        ? this.list(e, {}, t)
        : this._client.getAPIList(`/threads/${e}/runs`, Mt, {
            query: t,
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(n == null ? void 0 : n.headers),
            },
          });
    }
    cancel(e, t, n) {
      return this._client.post(`/threads/${e}/runs/${t}/cancel`, {
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
    async createAndPoll(e, t, n) {
      let s = await this.create(e, t, n);
      return await this.poll(e, s.id, n);
    }
    createAndStream(e, t, n) {
      return me.createAssistantStream(e, this._client.beta.threads.runs, t, n);
    }
    async poll(e, t, n) {
      let s = {
        ...(n == null ? void 0 : n.headers),
        "X-Stainless-Poll-Helper": "true",
      };
      for (
        n != null &&
        n.pollIntervalMs &&
        (s["X-Stainless-Custom-Poll-Interval"] = n.pollIntervalMs.toString());
        ;

      ) {
        let { data: a, response: i } = await this.retrieve(e, t, {
          ...n,
          headers: { ...(n == null ? void 0 : n.headers), ...s },
        }).withResponse();
        switch (a.status) {
          case "queued":
          case "in_progress":
          case "cancelling":
            let o = 5e3;
            if (n != null && n.pollIntervalMs) o = n.pollIntervalMs;
            else {
              let l = i.headers.get("openai-poll-after-ms");
              if (l) {
                let d = parseInt(l);
                isNaN(d) || (o = d);
              }
            }
            await be(o);
            break;
          case "requires_action":
          case "incomplete":
          case "cancelled":
          case "completed":
          case "failed":
          case "expired":
            return a;
        }
      }
    }
    stream(e, t, n) {
      return me.createAssistantStream(e, this._client.beta.threads.runs, t, n);
    }
    submitToolOutputs(e, t, n, s) {
      var a;
      return this._client.post(`/threads/${e}/runs/${t}/submit_tool_outputs`, {
        body: n,
        ...s,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(s == null ? void 0 : s.headers),
        },
        stream: (a = n.stream) != null ? a : !1,
      });
    }
    async submitToolOutputsAndPoll(e, t, n, s) {
      let a = await this.submitToolOutputs(e, t, n, s);
      return await this.poll(e, a.id, s);
    }
    submitToolOutputsStream(e, t, n, s) {
      return me.createToolAssistantStream(
        e,
        t,
        this._client.beta.threads.runs,
        n,
        s,
      );
    }
  },
  Mt = class extends O {};
Pe.RunsPage = Mt;
Pe.Steps = rt;
Pe.RunStepsPage = Rt;
var fe = class extends _ {
  constructor() {
    super(...arguments),
      (this.runs = new Pe(this._client)),
      (this.messages = new nt(this._client));
  }
  create(e = {}, t) {
    return F(e)
      ? this.create({}, e)
      : this._client.post("/threads", {
          body: e,
          ...t,
          headers: {
            "OpenAI-Beta": "assistants=v2",
            ...(t == null ? void 0 : t.headers),
          },
        });
  }
  retrieve(e, t) {
    return this._client.get(`/threads/${e}`, {
      ...t,
      headers: {
        "OpenAI-Beta": "assistants=v2",
        ...(t == null ? void 0 : t.headers),
      },
    });
  }
  update(e, t, n) {
    return this._client.post(`/threads/${e}`, {
      body: t,
      ...n,
      headers: {
        "OpenAI-Beta": "assistants=v2",
        ...(n == null ? void 0 : n.headers),
      },
    });
  }
  del(e, t) {
    return this._client.delete(`/threads/${e}`, {
      ...t,
      headers: {
        "OpenAI-Beta": "assistants=v2",
        ...(t == null ? void 0 : t.headers),
      },
    });
  }
  createAndRun(e, t) {
    var n;
    return this._client.post("/threads/runs", {
      body: e,
      ...t,
      headers: {
        "OpenAI-Beta": "assistants=v2",
        ...(t == null ? void 0 : t.headers),
      },
      stream: (n = e.stream) != null ? n : !1,
    });
  }
  async createAndRunPoll(e, t) {
    let n = await this.createAndRun(e, t);
    return await this.runs.poll(n.thread_id, n.id, t);
  }
  createAndRunStream(e, t) {
    return me.createThreadAssistantStream(e, this._client.beta.threads, t);
  }
};
fe.Runs = Pe;
fe.RunsPage = Mt;
fe.Messages = nt;
fe.MessagesPage = vt;
var re = class extends _ {
  constructor() {
    super(...arguments),
      (this.realtime = new $e(this._client)),
      (this.chat = new St(this._client)),
      (this.assistants = new Qe(this._client)),
      (this.threads = new fe(this._client));
  }
};
re.Realtime = $e;
re.Assistants = Qe;
re.AssistantsPage = _t;
re.Threads = fe;
var st = class extends _ {
  create(e, t) {
    var n;
    return this._client.post("/completions", {
      body: e,
      ...t,
      stream: (n = e.stream) != null ? n : !1,
    });
  }
};
var at = class extends _ {
  create(e, t) {
    let n = !!e.encoding_format,
      s = n ? e.encoding_format : "base64";
    n && _e("Request", "User defined encoding_format:", e.encoding_format);
    let a = this._client.post("/embeddings", {
      body: { ...e, encoding_format: s },
      ...t,
    });
    return n
      ? a
      : (_e("response", "Decoding base64 embeddings to float32 array"),
        a._thenUnwrap(
          (i) => (
            i &&
              i.data &&
              i.data.forEach((o) => {
                let l = o.embedding;
                o.embedding = Ss(l);
              }),
            i
          ),
        ));
  }
};
var Le = class extends _ {
    create(e, t) {
      return this._client.post("/files", ee({ body: e, ...t }));
    }
    retrieve(e, t) {
      return this._client.get(`/files/${e}`, t);
    }
    list(e = {}, t) {
      return F(e)
        ? this.list({}, e)
        : this._client.getAPIList("/files", it, { query: e, ...t });
    }
    del(e, t) {
      return this._client.delete(`/files/${e}`, t);
    }
    content(e, t) {
      return this._client.get(`/files/${e}/content`, {
        ...t,
        headers: {
          Accept: "application/binary",
          ...(t == null ? void 0 : t.headers),
        },
        __binaryResponse: !0,
      });
    }
    retrieveContent(e, t) {
      return this._client.get(`/files/${e}/content`, t);
    }
    async waitForProcessing(
      e,
      { pollInterval: t = 5e3, maxWait: n = 30 * 60 * 1e3 } = {},
    ) {
      let s = new Set(["processed", "error", "deleted"]),
        a = Date.now(),
        i = await this.retrieve(e);
      for (; !i.status || !s.has(i.status); )
        if ((await be(t), (i = await this.retrieve(e)), Date.now() - a > n))
          throw new Ie({
            message: `Giving up on waiting for file ${e} to finish processing after ${n} milliseconds.`,
          });
      return i;
    }
  },
  it = class extends O {};
Le.FileObjectsPage = it;
var ot = class extends _ {
    list(e, t = {}, n) {
      return F(t)
        ? this.list(e, {}, t)
        : this._client.getAPIList(`/fine_tuning/jobs/${e}/checkpoints`, Dt, {
            query: t,
            ...n,
          });
    }
  },
  Dt = class extends O {};
ot.FineTuningJobCheckpointsPage = Dt;
var he = class extends _ {
    constructor() {
      super(...arguments), (this.checkpoints = new ot(this._client));
    }
    create(e, t) {
      return this._client.post("/fine_tuning/jobs", { body: e, ...t });
    }
    retrieve(e, t) {
      return this._client.get(`/fine_tuning/jobs/${e}`, t);
    }
    list(e = {}, t) {
      return F(e)
        ? this.list({}, e)
        : this._client.getAPIList("/fine_tuning/jobs", Nt, { query: e, ...t });
    }
    cancel(e, t) {
      return this._client.post(`/fine_tuning/jobs/${e}/cancel`, t);
    }
    listEvents(e, t = {}, n) {
      return F(t)
        ? this.listEvents(e, {}, t)
        : this._client.getAPIList(`/fine_tuning/jobs/${e}/events`, Ot, {
            query: t,
            ...n,
          });
    }
  },
  Nt = class extends O {},
  Ot = class extends O {};
he.FineTuningJobsPage = Nt;
he.FineTuningJobEventsPage = Ot;
he.Checkpoints = ot;
he.FineTuningJobCheckpointsPage = Dt;
var pe = class extends _ {
  constructor() {
    super(...arguments), (this.jobs = new he(this._client));
  }
};
pe.Jobs = he;
pe.FineTuningJobsPage = Nt;
pe.FineTuningJobEventsPage = Ot;
var lt = class extends _ {
  createVariation(e, t) {
    return this._client.post("/images/variations", ee({ body: e, ...t }));
  }
  edit(e, t) {
    return this._client.post("/images/edits", ee({ body: e, ...t }));
  }
  generate(e, t) {
    return this._client.post("/images/generations", { body: e, ...t });
  }
};
var Be = class extends _ {
    retrieve(e, t) {
      return this._client.get(`/models/${e}`, t);
    }
    list(e) {
      return this._client.getAPIList("/models", ct, e);
    }
    del(e, t) {
      return this._client.delete(`/models/${e}`, t);
    }
  },
  ct = class extends ve {};
Be.ModelsPage = ct;
var ut = class extends _ {
  create(e, t) {
    return this._client.post("/moderations", { body: e, ...t });
  }
};
function js(r, e) {
  return !e || !xi(e)
    ? {
        ...r,
        output_parsed: null,
        output: r.output.map((t) =>
          t.type === "function_call"
            ? { ...t, parsed_arguments: null }
            : t.type === "message"
              ? {
                  ...t,
                  content: t.content.map((n) => ({ ...n, parsed: null })),
                }
              : t,
        ),
      }
    : qr(r, e);
}
function qr(r, e) {
  let t = r.output.map((s) => {
      if (s.type === "function_call")
        return { ...s, parsed_arguments: Ei(e, s) };
      if (s.type === "message") {
        let a = s.content.map((i) =>
          i.type === "output_text" ? { ...i, parsed: wi(e, i.text) } : i,
        );
        return { ...s, content: a };
      }
      return s;
    }),
    n = Object.assign({}, r, { output: t });
  return (
    Object.getOwnPropertyDescriptor(r, "output_text") || Wr(n),
    Object.defineProperty(n, "output_parsed", {
      enumerable: !0,
      get() {
        for (let s of n.output)
          if (s.type === "message") {
            for (let a of s.content)
              if (a.type === "output_text" && a.parsed !== null)
                return a.parsed;
          }
        return null;
      },
    }),
    n
  );
}
function wi(r, e) {
  var t, n, s, a;
  return ((n = (t = r.text) == null ? void 0 : t.format) == null
    ? void 0
    : n.type) !== "json_schema"
    ? null
    : "$parseRaw" in ((s = r.text) == null ? void 0 : s.format)
      ? ((a = r.text) == null ? void 0 : a.format).$parseRaw(e)
      : JSON.parse(e);
}
function xi(r) {
  var e;
  return !!on((e = r.text) == null ? void 0 : e.format);
}
function _i(r) {
  return (r == null ? void 0 : r.$brand) === "auto-parseable-tool";
}
function bi(r, e) {
  return r.find((t) => t.type === "function" && t.name === e);
}
function Ei(r, e) {
  var n;
  let t = bi((n = r.tools) != null ? n : [], e.name);
  return {
    ...e,
    ...e,
    parsed_arguments: _i(t)
      ? t.$parseRaw(e.arguments)
      : t != null && t.strict
        ? JSON.parse(e.arguments)
        : null,
  };
}
function Wr(r) {
  let e = [];
  for (let t of r.output)
    if (t.type === "message")
      for (let n of t.content) n.type === "output_text" && e.push(n.text);
  r.output_text = e.join("");
}
var kt = class extends _ {
  list(e, t = {}, n) {
    return F(t)
      ? this.list(e, {}, t)
      : this._client.getAPIList(`/responses/${e}/input_items`, Wn, {
          query: t,
          ...n,
        });
  }
};
var $t = function (r, e, t, n, s) {
    if (n === "m") throw new TypeError("Private method is not writable");
    if (n === "a" && !s)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? r !== e || !s : !e.has(r))
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it",
      );
    return n === "a" ? s.call(r, t) : s ? (s.value = t) : e.set(r, t), t;
  },
  Ue = function (r, e, t, n) {
    if (t === "a" && !n)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? r !== e || !n : !e.has(r))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it",
      );
    return t === "m" ? n : t === "a" ? n.call(r) : n ? n.value : e.get(r);
  },
  Lt,
  Hn,
  je,
  Jn,
  Vs,
  qs,
  Ws,
  Hs,
  Xn = class r extends Oe {
    constructor(e) {
      super(),
        Lt.add(this),
        Hn.set(this, void 0),
        je.set(this, void 0),
        Jn.set(this, void 0),
        $t(this, Hn, e, "f");
    }
    static createResponse(e, t, n) {
      let s = new r(t);
      return (
        s._run(() =>
          s._createResponse(e, t, {
            ...n,
            headers: {
              ...(n == null ? void 0 : n.headers),
              "X-Stainless-Helper-Method": "stream",
            },
          }),
        ),
        s
      );
    }
    async _createResponse(e, t, n) {
      var i;
      let s = n == null ? void 0 : n.signal;
      s &&
        (s.aborted && this.controller.abort(),
        s.addEventListener("abort", () => this.controller.abort())),
        Ue(this, Lt, "m", Vs).call(this);
      let a = await e.responses.create(
        { ...t, stream: !0 },
        { ...n, signal: this.controller.signal },
      );
      this._connected();
      for await (let o of a) Ue(this, Lt, "m", qs).call(this, o);
      if ((i = a.controller.signal) != null && i.aborted) throw new B();
      return Ue(this, Lt, "m", Ws).call(this);
    }
    [((Hn = new WeakMap()),
    (je = new WeakMap()),
    (Jn = new WeakMap()),
    (Lt = new WeakSet()),
    (Vs = function () {
      this.ended || $t(this, je, void 0, "f");
    }),
    (qs = function (t) {
      if (this.ended) return;
      let n = Ue(this, Lt, "m", Hs).call(this, t);
      switch ((this._emit("event", t), t.type)) {
        case "response.output_text.delta": {
          let s = n.output[t.output_index];
          if (!s) throw new C(`missing output at index ${t.output_index}`);
          if (s.type === "message") {
            let a = s.content[t.content_index];
            if (!a) throw new C(`missing content at index ${t.content_index}`);
            if (a.type !== "output_text")
              throw new C(
                `expected content to be 'output_text', got ${a.type}`,
              );
            this._emit("response.output_text.delta", {
              ...t,
              snapshot: a.text,
            });
          }
          break;
        }
        case "response.function_call_arguments.delta": {
          let s = n.output[t.output_index];
          if (!s) throw new C(`missing output at index ${t.output_index}`);
          s.type === "function_call" &&
            this._emit("response.function_call_arguments.delta", {
              ...t,
              snapshot: s.arguments,
            });
          break;
        }
        default:
          this._emit(t.type, t);
          break;
      }
    }),
    (Ws = function () {
      if (this.ended) throw new C("stream has ended, this shouldn't happen");
      let t = Ue(this, je, "f");
      if (!t) throw new C("request ended without sending any events");
      $t(this, je, void 0, "f");
      let n = Ai(t, Ue(this, Hn, "f"));
      return $t(this, Jn, n, "f"), n;
    }),
    (Hs = function (t) {
      let n = Ue(this, je, "f");
      if (!n) {
        if (t.type !== "response.created")
          throw new C(
            `When snapshot hasn't been set yet, expected 'response.created' event, got ${t.type}`,
          );
        return (n = $t(this, je, t.response, "f")), n;
      }
      switch (t.type) {
        case "response.output_item.added": {
          n.output.push(t.item);
          break;
        }
        case "response.content_part.added": {
          let s = n.output[t.output_index];
          if (!s) throw new C(`missing output at index ${t.output_index}`);
          s.type === "message" && s.content.push(t.part);
          break;
        }
        case "response.output_text.delta": {
          let s = n.output[t.output_index];
          if (!s) throw new C(`missing output at index ${t.output_index}`);
          if (s.type === "message") {
            let a = s.content[t.content_index];
            if (!a) throw new C(`missing content at index ${t.content_index}`);
            if (a.type !== "output_text")
              throw new C(
                `expected content to be 'output_text', got ${a.type}`,
              );
            a.text += t.delta;
          }
          break;
        }
        case "response.function_call_arguments.delta": {
          let s = n.output[t.output_index];
          if (!s) throw new C(`missing output at index ${t.output_index}`);
          s.type === "function_call" && (s.arguments += t.delta);
          break;
        }
        case "response.completed": {
          $t(this, je, t.response, "f");
          break;
        }
      }
      return n;
    }),
    Symbol.asyncIterator)]() {
      let e = [],
        t = [],
        n = !1;
      return (
        this.on("event", (s) => {
          let a = t.shift();
          a ? a.resolve(s) : e.push(s);
        }),
        this.on("end", () => {
          n = !0;
          for (let s of t) s.resolve(void 0);
          t.length = 0;
        }),
        this.on("abort", (s) => {
          n = !0;
          for (let a of t) a.reject(s);
          t.length = 0;
        }),
        this.on("error", (s) => {
          n = !0;
          for (let a of t) a.reject(s);
          t.length = 0;
        }),
        {
          next: async () =>
            e.length
              ? { value: e.shift(), done: !1 }
              : n
                ? { value: void 0, done: !0 }
                : new Promise((a, i) => t.push({ resolve: a, reject: i })).then(
                    (a) =>
                      a ? { value: a, done: !1 } : { value: void 0, done: !0 },
                  ),
          return: async () => (this.abort(), { value: void 0, done: !0 }),
        }
      );
    }
    async finalResponse() {
      await this.done();
      let e = Ue(this, Jn, "f");
      if (!e) throw new C("stream ended without producing a ChatCompletion");
      return e;
    }
  };
function Ai(r, e) {
  return js(r, e);
}
var Ve = class extends _ {
    constructor() {
      super(...arguments), (this.inputItems = new kt(this._client));
    }
    create(e, t) {
      var n;
      return this._client
        .post("/responses", {
          body: e,
          ...t,
          stream: (n = e.stream) != null ? n : !1,
        })
        ._thenUnwrap(
          (s) => ("object" in s && s.object === "response" && Wr(s), s),
        );
    }
    retrieve(e, t = {}, n) {
      return F(t)
        ? this.retrieve(e, {}, t)
        : this._client.get(`/responses/${e}`, { query: t, ...n });
    }
    del(e, t) {
      return this._client.delete(`/responses/${e}`, {
        ...t,
        headers: { Accept: "*/*", ...(t == null ? void 0 : t.headers) },
      });
    }
    parse(e, t) {
      return this._client.responses.create(e, t)._thenUnwrap((n) => qr(n, e));
    }
    stream(e, t) {
      return Xn.createResponse(this._client, e, t);
    }
  },
  Wn = class extends O {};
Ve.InputItems = kt;
var Bt = class extends _ {
  create(e, t, n) {
    return this._client.post(`/uploads/${e}/parts`, ee({ body: t, ...n }));
  }
};
var qe = class extends _ {
  constructor() {
    super(...arguments), (this.parts = new Bt(this._client));
  }
  create(e, t) {
    return this._client.post("/uploads", { body: e, ...t });
  }
  cancel(e, t) {
    return this._client.post(`/uploads/${e}/cancel`, t);
  }
  complete(e, t, n) {
    return this._client.post(`/uploads/${e}/complete`, { body: t, ...n });
  }
};
qe.Parts = Bt;
var Js = async (r) => {
  let e = await Promise.allSettled(r),
    t = e.filter((s) => s.status === "rejected");
  if (t.length) {
    for (let s of t) console.error(s.reason);
    throw new Error(`${t.length} promise(s) failed - see the above errors`);
  }
  let n = [];
  for (let s of e) s.status === "fulfilled" && n.push(s.value);
  return n;
};
var We = class extends _ {
    create(e, t, n) {
      return this._client.post(`/vector_stores/${e}/files`, {
        body: t,
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
    retrieve(e, t, n) {
      return this._client.get(`/vector_stores/${e}/files/${t}`, {
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
    update(e, t, n, s) {
      return this._client.post(`/vector_stores/${e}/files/${t}`, {
        body: n,
        ...s,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(s == null ? void 0 : s.headers),
        },
      });
    }
    list(e, t = {}, n) {
      return F(t)
        ? this.list(e, {}, t)
        : this._client.getAPIList(`/vector_stores/${e}/files`, He, {
            query: t,
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(n == null ? void 0 : n.headers),
            },
          });
    }
    del(e, t, n) {
      return this._client.delete(`/vector_stores/${e}/files/${t}`, {
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
    async createAndPoll(e, t, n) {
      let s = await this.create(e, t, n);
      return await this.poll(e, s.id, n);
    }
    async poll(e, t, n) {
      let s = {
        ...(n == null ? void 0 : n.headers),
        "X-Stainless-Poll-Helper": "true",
      };
      for (
        n != null &&
        n.pollIntervalMs &&
        (s["X-Stainless-Custom-Poll-Interval"] = n.pollIntervalMs.toString());
        ;

      ) {
        let a = await this.retrieve(e, t, { ...n, headers: s }).withResponse(),
          i = a.data;
        switch (i.status) {
          case "in_progress":
            let o = 5e3;
            if (n != null && n.pollIntervalMs) o = n.pollIntervalMs;
            else {
              let l = a.response.headers.get("openai-poll-after-ms");
              if (l) {
                let d = parseInt(l);
                isNaN(d) || (o = d);
              }
            }
            await be(o);
            break;
          case "failed":
          case "completed":
            return i;
        }
      }
    }
    async upload(e, t, n) {
      let s = await this._client.files.create(
        { file: t, purpose: "assistants" },
        n,
      );
      return this.create(e, { file_id: s.id }, n);
    }
    async uploadAndPoll(e, t, n) {
      let s = await this.upload(e, t, n);
      return await this.poll(e, s.id, n);
    }
    content(e, t, n) {
      return this._client.getAPIList(
        `/vector_stores/${e}/files/${t}/content`,
        Ut,
        {
          ...n,
          headers: {
            "OpenAI-Beta": "assistants=v2",
            ...(n == null ? void 0 : n.headers),
          },
        },
      );
    }
  },
  He = class extends O {},
  Ut = class extends ve {};
We.VectorStoreFilesPage = He;
We.FileContentResponsesPage = Ut;
var jt = class extends _ {
  create(e, t, n) {
    return this._client.post(`/vector_stores/${e}/file_batches`, {
      body: t,
      ...n,
      headers: {
        "OpenAI-Beta": "assistants=v2",
        ...(n == null ? void 0 : n.headers),
      },
    });
  }
  retrieve(e, t, n) {
    return this._client.get(`/vector_stores/${e}/file_batches/${t}`, {
      ...n,
      headers: {
        "OpenAI-Beta": "assistants=v2",
        ...(n == null ? void 0 : n.headers),
      },
    });
  }
  cancel(e, t, n) {
    return this._client.post(`/vector_stores/${e}/file_batches/${t}/cancel`, {
      ...n,
      headers: {
        "OpenAI-Beta": "assistants=v2",
        ...(n == null ? void 0 : n.headers),
      },
    });
  }
  async createAndPoll(e, t, n) {
    let s = await this.create(e, t);
    return await this.poll(e, s.id, n);
  }
  listFiles(e, t, n = {}, s) {
    return F(n)
      ? this.listFiles(e, t, {}, n)
      : this._client.getAPIList(
          `/vector_stores/${e}/file_batches/${t}/files`,
          He,
          {
            query: n,
            ...s,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(s == null ? void 0 : s.headers),
            },
          },
        );
  }
  async poll(e, t, n) {
    let s = {
      ...(n == null ? void 0 : n.headers),
      "X-Stainless-Poll-Helper": "true",
    };
    for (
      n != null &&
      n.pollIntervalMs &&
      (s["X-Stainless-Custom-Poll-Interval"] = n.pollIntervalMs.toString());
      ;

    ) {
      let { data: a, response: i } = await this.retrieve(e, t, {
        ...n,
        headers: s,
      }).withResponse();
      switch (a.status) {
        case "in_progress":
          let o = 5e3;
          if (n != null && n.pollIntervalMs) o = n.pollIntervalMs;
          else {
            let l = i.headers.get("openai-poll-after-ms");
            if (l) {
              let d = parseInt(l);
              isNaN(d) || (o = d);
            }
          }
          await be(o);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return a;
      }
    }
  }
  async uploadAndPoll(e, { files: t, fileIds: n = [] }, s) {
    var y;
    if (t == null || t.length == 0)
      throw new Error(
        "No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead",
      );
    let a = (y = s == null ? void 0 : s.maxConcurrency) != null ? y : 5,
      i = Math.min(a, t.length),
      o = this._client,
      l = t.values(),
      d = [...n];
    async function f(h) {
      for (let b of h) {
        let x = await o.files.create({ file: b, purpose: "assistants" }, s);
        d.push(x.id);
      }
    }
    let m = Array(i).fill(l).map(f);
    return await Js(m), await this.createAndPoll(e, { file_ids: d });
  }
};
var z = class extends _ {
    constructor() {
      super(...arguments),
        (this.files = new We(this._client)),
        (this.fileBatches = new jt(this._client));
    }
    create(e, t) {
      return this._client.post("/vector_stores", {
        body: e,
        ...t,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(t == null ? void 0 : t.headers),
        },
      });
    }
    retrieve(e, t) {
      return this._client.get(`/vector_stores/${e}`, {
        ...t,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(t == null ? void 0 : t.headers),
        },
      });
    }
    update(e, t, n) {
      return this._client.post(`/vector_stores/${e}`, {
        body: t,
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
    list(e = {}, t) {
      return F(e)
        ? this.list({}, e)
        : this._client.getAPIList("/vector_stores", dt, {
            query: e,
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(t == null ? void 0 : t.headers),
            },
          });
    }
    del(e, t) {
      return this._client.delete(`/vector_stores/${e}`, {
        ...t,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(t == null ? void 0 : t.headers),
        },
      });
    }
    search(e, t, n) {
      return this._client.getAPIList(`/vector_stores/${e}/search`, mt, {
        body: t,
        method: "post",
        ...n,
        headers: {
          "OpenAI-Beta": "assistants=v2",
          ...(n == null ? void 0 : n.headers),
        },
      });
    }
  },
  dt = class extends O {},
  mt = class extends ve {};
z.VectorStoresPage = dt;
z.VectorStoreSearchResponsesPage = mt;
z.Files = We;
z.VectorStoreFilesPage = He;
z.FileContentResponsesPage = Ut;
z.FileBatches = jt;
var Xs,
  S = class extends Fn {
    constructor({
      baseURL: e = en("OPENAI_BASE_URL"),
      apiKey: t = en("OPENAI_API_KEY"),
      organization: n = ((i) =>
        (i = en("OPENAI_ORG_ID")) != null ? i : null)(),
      project: s = ((o) =>
        (o = en("OPENAI_PROJECT_ID")) != null ? o : null)(),
      ...a
    } = {}) {
      var d;
      if (t === void 0)
        throw new C(
          "The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).",
        );
      let l = {
        apiKey: t,
        organization: n,
        project: s,
        ...a,
        baseURL: e || "https://api.openai.com/v1",
      };
      if (!l.dangerouslyAllowBrowser && Ps())
        throw new C(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
      super({
        baseURL: l.baseURL,
        timeout: (d = l.timeout) != null ? d : 6e5,
        httpAgent: l.httpAgent,
        maxRetries: l.maxRetries,
        fetch: l.fetch,
      }),
        (this.completions = new st(this)),
        (this.chat = new Ee(this)),
        (this.embeddings = new at(this)),
        (this.files = new Le(this)),
        (this.images = new lt(this)),
        (this.audio = new ue(this)),
        (this.moderations = new ut(this)),
        (this.models = new Be(this)),
        (this.fineTuning = new pe(this)),
        (this.vectorStores = new z(this)),
        (this.beta = new re(this)),
        (this.batches = new De(this)),
        (this.uploads = new qe(this)),
        (this.responses = new Ve(this)),
        (this._options = l),
        (this.apiKey = t),
        (this.organization = n),
        (this.project = s);
    }
    defaultQuery() {
      return this._options.defaultQuery;
    }
    defaultHeaders(e) {
      return {
        ...super.defaultHeaders(e),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project,
        ...this._options.defaultHeaders,
      };
    }
    authHeaders(e) {
      return { Authorization: `Bearer ${this.apiKey}` };
    }
    stringifyQuery(e) {
      return or(e, { arrayFormat: "brackets" });
    }
  };
Xs = S;
S.OpenAI = Xs;
S.DEFAULT_TIMEOUT = 6e5;
S.OpenAIError = C;
S.APIError = j;
S.APIConnectionError = Te;
S.APIConnectionTimeoutError = Ie;
S.APIUserAbortError = B;
S.NotFoundError = Xt;
S.ConflictError = Kt;
S.RateLimitError = Yt;
S.BadRequestError = Wt;
S.AuthenticationError = Ht;
S.InternalServerError = zt;
S.PermissionDeniedError = Jt;
S.UnprocessableEntityError = Gt;
S.toFile = _r;
S.fileFromPath = bn;
S.Completions = st;
S.Chat = Ee;
S.ChatCompletionsPage = Me;
S.Embeddings = at;
S.Files = Le;
S.FileObjectsPage = it;
S.Images = lt;
S.Audio = ue;
S.Moderations = ut;
S.Models = Be;
S.ModelsPage = ct;
S.FineTuning = pe;
S.VectorStores = z;
S.VectorStoresPage = dt;
S.VectorStoreSearchResponsesPage = mt;
S.Beta = re;
S.Batches = De;
S.BatchesPage = ze;
S.Uploads = qe;
S.Responses = Ve;
var Ks = S;
async function se(r, e, t = !0) {
  let n = "",
    s = null;
  t && (s = new ge.Notice(c("llmLoading"), 0));
  let a = new Ks({
    apiKey: e.llmToken,
    baseURL: e.llmBaseUrl,
    dangerouslyAllowBrowser: !0,
  });
  try {
    let i = await a.chat.completions.create({
      model: e.llmModelName,
      messages: [{ role: "user", content: r }],
    });
    i.choices.length > 0 && (n = i.choices[0].message.content || n);
  } catch (i) {
    new ge.Notice(
      c("llmError") +
        `
` +
        i,
    ),
      console.warn("Error:", i);
  }
  return s && s.hide(), n;
}
var Hr = class extends ge.Modal {
  constructor(e, t, n, s, a) {
    super(e),
      (this.message = t),
      (this.resolvePromise = n),
      (this.yesText = s || c("yes")),
      (this.noText = a || c("no")),
      (this.resolved = !1);
  }
  onOpen() {
    this.titleEl.setText(c("confirm")),
      this.message
        .split(
          `
`,
        )
        .forEach((a) => {
          a.trim() && this.contentEl.createEl("p", { text: a });
        });
    let t = this.contentEl.createEl("div", { cls: "dialog-button-container" }),
      n = t.createEl("button", { text: this.yesText });
    n.onclick = () => {
      (this.resolved = !0), this.close(), this.resolvePromise(!0);
    };
    let s = t.createEl("button", { text: this.noText });
    s.onclick = () => {
      (this.resolved = !0), this.close(), this.resolvePromise(!1);
    };
  }
  onClose() {
    this.resolved || this.resolvePromise(void 0);
  }
};
async function pn(r, e, t, n) {
  return new Promise((s) => {
    new Hr(r, e, s, t, n).open();
  });
}
function qt(r) {
  let e = /[\u4e00-\u9fa5]|[a-zA-Z0-9]+|[\.,!?;，。！？；#]|[\n]/g;
  return r.match(e) || [];
}
function Vt(r) {
  let e = "";
  for (let t = 0; t < r.length; t++) {
    let n = r[t];
    n ===
      `
` || /[\u4e00-\u9fa5]|[\.,!?;，。！？；#]/.test(n)
      ? (e += n)
      : (e += (t > 0 ? " " : "") + n);
  }
  return e.trim();
}
var Gs = 30;
async function Fi(r, e, t) {
  let n = r.join(","),
    s = qt(n).length,
    a = c("simplifyTagsConfirm").replace("{count}", s.toString());
  if (!(await pn(e, a))) return null;
  let o = c("simplifyTagsPrompt").replace("{count}", Gs.toString()),
    l = await se(
      o +
        `

` +
        r.join(`
`),
      t,
      !0,
    );
  return l
    ? l
        .split(
          `
`,
        )
        .filter((d) => d.trim())
    : (new ge.Notice(c("llmError")), null);
}
async function Ys(r, e) {
  let t = {};
  r.vault.getMarkdownFiles().forEach((s) => {
    let a = r.metadataCache.getFileCache(s);
    if (a) {
      let i = (0, ge.getAllTags)(a);
      i &&
        i.forEach((o) => {
          let l = o;
          l.startsWith("#") && (l = l.slice(1)), t[l] ? t[l]++ : (t[l] = 1);
        });
    }
  });
  let n = Object.keys(t);
  if (n.length > Gs) {
    let s = await Fi(n, r, e);
    if (s) {
      let a = {};
      return (
        s.forEach((i) => {
          a[i] = t[i] || 3;
        }),
        a
      );
    }
  }
  return t;
}
function Jr(r, e, t) {
  let n = new RegExp(`## ${e}[\\s\\S]*?(?=##|$)`);
  return n.test(r)
    ? r.replace(
        n,
        `${t}

`,
      )
    : r.trim() +
        `

` +
        t +
        `
`;
}
function vi(r, e) {
  let t = new RegExp(`## ${e}[\\s\\S]*?(?=##|$)`),
    n = r.match(t);
  return n
    ? n[0]
        .replace(
          new RegExp(`## ${e}
?`),
          "",
        )
        .trim()
    : "";
}
async function zs(r, e, t, n = !1) {
  var i;
  let s = "";
  if (e !== null) {
    if (((s = await r.vault.read(e)), t && ft(e, t))) {
      let o = vi(s, c("fileDetail"));
      o && (s = o);
    } else if (!n && s.startsWith("---")) {
      let o = s.indexOf("---", 3);
      o !== -1 && (s = s.substring(o + 3).trim());
    }
  } else {
    let o =
      (i = r.workspace.getActiveViewOfType(ge.MarkdownView)) == null
        ? void 0
        : i.editor;
    if (!o) return "";
    if (
      ((s = o.getSelection()),
      (s = s.trim()),
      s.length === 0 && ((s = o.getValue()), !n && s.startsWith("---")))
    ) {
      let l = s.indexOf("---", 3);
      l !== -1 && (s = s.substring(l + 3).trim());
    }
  }
  if (s.length === 0) return "";
  if (!(t != null && t.metaIsTruncate)) return s;
  let a = qt(s);
  if (
    (t == null ? void 0 : t.metaMaxTokens) > 0 &&
    a.length > t.metaMaxTokens
  ) {
    let o = t.metaTruncateMethod;
    if (o === "head_tail") {
      let l = Math.round(t.metaMaxTokens * 0.8),
        d = Math.round(t.metaMaxTokens * 0.2),
        f = a.slice(0, l),
        m = a.slice(-d);
      s =
        Vt(f) +
        `
...
` +
        Vt(m);
    } else if (o === "head_only") s = Vt(a.slice(0, t.metaMaxTokens)) + "...";
    else if (o === "heading") {
      let l = s.split(`
`);
      l = l.filter((y) => y.trim() !== "");
      let d = [],
        f = !1;
      for (let y of l)
        if (y.startsWith("#")) d.push(y), (f = !0);
        else if (f && y.trim() !== "") {
          let h = qt(y);
          d.push(Vt(h.slice(0, 30)) + "..."), (f = !1);
        }
      s = d.join(`
`);
      let m = qt(s);
      if (m.length > t.metaMaxTokens) s = Vt(m.slice(0, t.metaMaxTokens));
      else {
        let y = t.metaMaxTokens - m.length,
          h = Vt(a.slice(0, y)) + "...";
        s = `Outline: 
${s}

Body: ${h}`;
      }
    }
  }
  return s;
}
function ae(r, e, t, n, s) {
  e.fileManager.processFrontMatter(r, (a) => {
    if (n != null)
      if (s === "append") {
        let i = a[t];
        if (typeof n == "string") i == null && (i = ""), (a[t] = i + n);
        else if (Array.isArray(n)) {
          (i == null || !Array.isArray(i)) && (i = []);
          let o = i.concat(n),
            l = Array.from(new Set(o));
          a[t] = l;
        }
      } else if (s === "update") a[t] = n;
      else {
        let i = a[t];
        if (i != null) return;
        a[t] = n;
      }
  });
}
function ft(r, e) {
  return !!r.basename.startsWith(e.defaultIndexString);
}
var Kn = class extends T.PluginSettingTab {
  constructor(e, t) {
    super(e, t), (this.plugin = t);
  }
  display() {
    let { containerEl: e } = this;
    e.empty(),
      this.addGeneralSettings(),
      this.addLLMSettings(),
      this.addFolderSettings(),
      this.addMetadataSettings(),
      this.addIndexFileSettings(),
      this.addDonationSettings();
  }
  addGeneralSettings() {
    new T.Setting(this.containerEl).setName(c("llmSettings")).setHeading(),
      new T.Setting(this.containerEl).setName(c("apiKey")).addText((e) =>
        e
          .setPlaceholder("Enter your token")
          .setValue(this.plugin.settings.llmToken)
          .onChange(async (t) => {
            (this.plugin.settings.llmToken = t),
              await this.plugin.saveSettings();
          }),
      ),
      new T.Setting(this.containerEl).setName(c("baseUrl")).addText((e) =>
        e
          .setPlaceholder("https://api.openai.com/v1")
          .setValue(this.plugin.settings.llmBaseUrl)
          .onChange(async (t) => {
            (this.plugin.settings.llmBaseUrl = t),
              await this.plugin.saveSettings();
          }),
      ),
      new T.Setting(this.containerEl).setName(c("modelName")).addText((e) =>
        e
          .setPlaceholder("gpt-4o")
          .setValue(this.plugin.settings.llmModelName)
          .onChange(async (t) => {
            (this.plugin.settings.llmModelName = t),
              await this.plugin.saveSettings();
          }),
      );
  }
  addLLMSettings() {
    let t = this.containerEl
      .createEl("div")
      .createEl("details", { cls: "setting-item-collapse" });
    t.createEl("summary", { text: c("llmAssistantSetting") }),
      t
        .createEl("div", { cls: "setting-item-description" })
        .setText(c("llmAssistantSettingDesc")),
      new T.Setting(t)
        .setName(c("llmAssistantDialogEdit"))
        .setDesc(c("llmAssistantDialogEditDesc"))
        .addToggle((s) => {
          s.setValue(this.plugin.settings.llmDialogEdit).onChange(async (a) => {
            (this.plugin.settings.llmDialogEdit = a),
              await this.plugin.saveSettings();
          });
        }),
      new T.Setting(t)
        .setName(c("managePrompts"))
        .setDesc(c("managePromptsDesc"))
        .addButton((s) =>
          s
            .setButtonText(c("openPromptManager"))
            .setCta()
            .onClick(() => {
              new yn(this.app, this.plugin).open();
            }),
        );
  }
  addFolderSettings() {
    let t = this.containerEl
      .createEl("div")
      .createEl("details", { cls: "setting-item-collapse" });
    t.createEl("summary", { text: c("folderSelectionSetting") }),
      t
        .createEl("div", { cls: "setting-item-description" })
        .setText(c("folderSelectionSettingDesc")),
      new T.Setting(t)
        .setName(c("excludedFolders"))
        .setDesc(c("excludedFoldersDesc"))
        .addTextArea((s) => {
          s
            .setValue(
              this.plugin.settings.selectExcludedFolders.join(`
`),
            )
            .onChange(async (a) => {
              (this.plugin.settings.selectExcludedFolders = a
                .split(
                  `
`,
                )
                .map((i) => i.trim())
                .filter((i) => i !== "")),
                await this.plugin.saveSettings();
            }),
            s.inputEl.setAttr("rows", "3"),
            s.inputEl.addClass("setting-textarea");
        });
  }
  addMetadataSettings() {
    let t = this.containerEl.createEl("div").createEl("details", {
      cls: "setting-item-collapse",
      attr: { id: "meta-settings-collapse" },
    });
    t.createEl("summary", { text: c("metaSetting") }),
      t
        .createEl("div", { cls: "setting-item-description" })
        .setText(c("metaSettingDesc")),
      new T.Setting(t)
        .setName(c("metaUpdateSetting"))
        .setDesc(c("updateMetaOptionsDesc"))
        .setClass("setting-item-indent1")
        .addDropdown((u) => {
          u.addOption("force", c("updateForce"))
            .addOption("no-llm", c("updateNoLLM"))
            .setValue(this.plugin.settings.metaUpdateMethod)
            .onChange(async (p) => {
              (this.plugin.settings.metaUpdateMethod = p),
                await this.plugin.saveSettings();
            });
        });
    let s = t.createEl("details", {
      cls: "setting-item-collapse nested-settings",
    });
    s.createEl("summary", { text: c("truncateSettings") }),
      new T.Setting(s)
        .setName(c("truncateContent"))
        .setDesc(c("truncateContentDesc"))
        .addToggle((u) => {
          u.setValue(this.plugin.settings.metaIsTruncate).onChange(
            async (p) => {
              (this.plugin.settings.metaIsTruncate = p),
                await this.plugin.saveSettings(),
                (a.style.display = p ? "block" : "none");
            },
          );
        });
    let a = s.createEl("div", { cls: "setting-item-indent2" });
    new T.Setting(a)
      .setName(c("maxContentLength"))
      .setDesc(c("maxContentLengthDesc"))
      .addText((u) => {
        u.setValue(this.plugin.settings.metaMaxTokens.toString()).onChange(
          async (p) => {
            (this.plugin.settings.metaMaxTokens = parseInt(p)),
              await this.plugin.saveSettings();
          },
        );
      }),
      new T.Setting(a)
        .setName(c("truncateMethod"))
        .setDesc(c("truncateMethodDesc"))
        .addDropdown((u) => {
          u.addOption("head_only", c("head_only"))
            .addOption("head_tail", c("head_tail"))
            .addOption("heading", c("heading"))
            .setValue(this.plugin.settings.metaTruncateMethod)
            .onChange(async (p) => {
              (this.plugin.settings.metaTruncateMethod = p),
                await this.plugin.saveSettings();
            });
        }),
      (a.style.display = this.plugin.settings.metaIsTruncate
        ? "block"
        : "none");
    let i = t.createEl("details", {
      cls: "setting-item-collapse nested-settings",
    });
    i.createEl("summary", { text: c("description") }),
      new T.Setting(i)
        .setName(c("descriptionFieldName"))
        .setDesc(c("descriptionFieldNameDesc"))
        .addText((u) =>
          u
            .setValue(this.plugin.settings.metaDescriptionFieldName)
            .onChange(async (p) => {
              (this.plugin.settings.metaDescriptionFieldName =
                p || "description"),
                await this.plugin.saveSettings();
            }),
        ),
      new T.Setting(i)
        .setName(c("descriptionPrompt"))
        .setDesc(c("descriptionPromptDesc"))
        .addTextArea((u) => {
          u
            .setValue(this.plugin.settings.metaDescription)
            .onChange(async (p) => {
              (this.plugin.settings.metaDescription = p),
                await this.plugin.saveSettings();
            }),
            u.inputEl.setAttr("rows", "3"),
            u.inputEl.addClass("setting-textarea");
        });
    let o = t.createEl("details", {
      cls: "setting-item-collapse nested-settings",
    });
    o.createEl("summary", { text: c("taggingOptions") });
    let l;
    new T.Setting(o)
      .setName(c("tagsFieldName"))
      .setDesc(c("tagsFieldNameDesc"))
      .addText((u) =>
        u
          .setValue(this.plugin.settings.metaTagsFieldName)
          .onChange(async (p) => {
            (this.plugin.settings.metaTagsFieldName = p || "tags"),
              await this.plugin.saveSettings();
          }),
      ),
      new T.Setting(o)
        .setName(c("extractTags"))
        .setDesc(c("extractTagsDesc"))
        .addButton((u) => {
          u.setButtonText(c("extract"))
            .setCta()
            .onClick(async () => {
              let p = await Ys(this.app, this.plugin.settings),
                g = Object.entries(p)
                  .sort((E, I) => I[1] - E[1])
                  .filter(([E, I]) => I > 2)
                  .map(([E]) => E),
                A = this.plugin.settings.tags;
              for (let E of g) A.includes(E) || A.push(E);
              (this.plugin.settings.tags = A),
                l.setValue(
                  this.plugin.settings.tags.join(`
`),
                );
            });
        }),
      new T.Setting(o)
        .setName(c("tagList"))
        .setDesc(c("tagListDesc"))
        .addTextArea((u) => {
          (l = u),
            u
              .setValue(
                this.plugin.settings.tags.join(`
`),
              )
              .onChange(async (p) => {
                (this.plugin.settings.tags = p
                  .split(
                    `
`,
                  )
                  .map((w) => w.trim())
                  .filter((w) => w !== "")),
                  await this.plugin.saveSettings();
              }),
            u.inputEl.setAttr("rows", "7"),
            u.inputEl.addClass("setting-textarea");
        }),
      new T.Setting(o)
        .setName(c("metaTagsPrompt"))
        .setDesc(c("metaTagsPromptDesc"))
        .addTextArea((u) => {
          u
            .setPlaceholder(this.plugin.settings.metaTagsPrompt)
            .setValue(this.plugin.settings.metaTagsPrompt)
            .onChange(async (p) => {
              (this.plugin.settings.metaTagsPrompt = p),
                await this.plugin.saveSettings();
            }),
            u.inputEl.setAttr("rows", "3"),
            u.inputEl.addClass("setting-textarea");
        });
    let d = t.createEl("details", {
      cls: "setting-item-collapse nested-settings",
    });
    d.createEl("summary", { text: c("categoryOptions") }),
      new T.Setting(d)
        .setName(c("enableCategory"))
        .setDesc(c("enableCategoryDesc"))
        .addToggle((u) =>
          u
            .setValue(this.plugin.settings.metaCategoryEnabled)
            .onChange(async (p) => {
              (this.plugin.settings.metaCategoryEnabled = p),
                await this.plugin.saveSettings();
            }),
        ),
      new T.Setting(d)
        .setName(c("categoryFieldName"))
        .setDesc(c("categoryFieldNameDesc"))
        .addText((u) =>
          u
            .setValue(this.plugin.settings.metaCategoryFieldName)
            .onChange(async (p) => {
              (this.plugin.settings.metaCategoryFieldName = p || "category"),
                await this.plugin.saveSettings();
            }),
        ),
      new T.Setting(d)
        .setName(c("categoryList"))
        .setDesc(c("categoryListDesc"))
        .addTextArea((u) => {
          u
            .setValue(
              this.plugin.settings.categories.join(`
`),
            )
            .onChange(async (p) => {
              (this.plugin.settings.categories = p
                .split(
                  `
`,
                )
                .map((w) => w.trim())
                .filter((w) => w !== "")),
                await this.plugin.saveSettings();
            }),
            u.inputEl.setAttr("rows", "5"),
            u.inputEl.addClass("setting-textarea");
        }),
      new T.Setting(d)
        .setName(c("metaCategoryPrompt"))
        .setDesc(c("metaCategoryPromptDesc"))
        .addTextArea((u) => {
          u
            .setPlaceholder(this.plugin.settings.metaCategoryPrompt)
            .setValue(this.plugin.settings.metaCategoryPrompt)
            .onChange(async (p) => {
              (this.plugin.settings.metaCategoryPrompt = p),
                await this.plugin.saveSettings();
            }),
            u.inputEl.setAttr("rows", "3"),
            u.inputEl.addClass("setting-textarea");
        });
    let f = t.createEl("details", {
      cls: "setting-item-collapse nested-settings",
    });
    f.createEl("summary", { text: c("title") }),
      new T.Setting(f)
        .setName(c("enableTitle"))
        .setDesc(c("enableTitleDesc"))
        .addToggle((u) => {
          u.setValue(this.plugin.settings.metaTitleEnabled).onChange(
            async (p) => {
              (this.plugin.settings.metaTitleEnabled = p),
                await this.plugin.saveSettings(),
                m.setDisabled(!p);
            },
          );
        }),
      new T.Setting(f)
        .setName(c("titleFieldName"))
        .setDesc(c("titleFieldNameDesc"))
        .addText((u) =>
          u
            .setValue(this.plugin.settings.metaTitleFieldName)
            .onChange(async (p) => {
              (this.plugin.settings.metaTitleFieldName = p || "title"),
                await this.plugin.saveSettings();
            }),
        );
    let m = new T.Setting(f)
      .setName(c("titlePrompt"))
      .setDesc(c("titlePromptDesc"))
      .addTextArea((u) => {
        u.setValue(this.plugin.settings.metaTitlePrompt).onChange(async (p) => {
          (this.plugin.settings.metaTitlePrompt = p),
            await this.plugin.saveSettings();
        }),
          u.inputEl.setAttr("rows", "3"),
          u.inputEl.addClass("setting-textarea");
      });
    m.setDisabled(!this.plugin.settings.metaTitleEnabled);
    let y = t.createEl("details", {
      cls: "setting-item-collapse nested-settings",
    });
    y.createEl("summary", { text: c("coverImage") }),
      new T.Setting(y)
        .setName(c("enableCover"))
        .setDesc(c("enableCoverDesc"))
        .addToggle((u) =>
          u
            .setValue(this.plugin.settings.metaCoverEnabled)
            .onChange(async (p) => {
              (this.plugin.settings.metaCoverEnabled = p),
                await this.plugin.saveSettings();
            }),
        ),
      new T.Setting(y)
        .setName(c("coverFieldName"))
        .setDesc(c("coverFieldNameDesc"))
        .addText((u) =>
          u
            .setValue(this.plugin.settings.metaCoverFieldName)
            .onChange(async (p) => {
              (this.plugin.settings.metaCoverFieldName = p || "cover"),
                await this.plugin.saveSettings();
            }),
        ),
      new T.Setting(y)
        .setName(c("coverUrl"))
        .setDesc(c("coverUrlDesc"))
        .addText((u) =>
          u.setValue(this.plugin.settings.metaCoverUrl).onChange(async (p) => {
            (this.plugin.settings.metaCoverUrl = p),
              await this.plugin.saveSettings();
          }),
        ),
      new T.Setting(y)
        .setName(c("useFirstImage"))
        .setDesc(c("useFirstImageDesc"))
        .addToggle((u) =>
          u
            .setValue(this.plugin.settings.metaCoverUseFirst)
            .onChange(async (p) => {
              (this.plugin.settings.metaCoverUseFirst = p),
                await this.plugin.saveSettings();
            }),
        );
    let h = t.createEl("details", {
      cls: "setting-item-collapse nested-settings",
    });
    h.createEl("summary", { text: c("editTime") }),
      new T.Setting(h)
        .setName(c("enableEditTime"))
        .setDesc(c("enableEditTimeDesc"))
        .addToggle((u) => {
          u.setValue(this.plugin.settings.metaEditTimeEnabled).onChange(
            async (p) => {
              (this.plugin.settings.metaEditTimeEnabled = p),
                await this.plugin.saveSettings(),
                b.setDisabled(!p);
            },
          );
        }),
      new T.Setting(h)
        .setName(c("updateTimeFieldName"))
        .setDesc(c("updateTimeFieldNameDesc"))
        .addText((u) =>
          u
            .setValue(this.plugin.settings.metaUpdatedFieldName)
            .onChange(async (p) => {
              (this.plugin.settings.metaUpdatedFieldName = p || "updated"),
                await this.plugin.saveSettings();
            }),
        ),
      new T.Setting(h)
        .setName(c("createTimeFieldName"))
        .setDesc(c("createTimeFieldNameDesc"))
        .addText((u) =>
          u
            .setValue(this.plugin.settings.metaCreatedFieldName)
            .onChange(async (p) => {
              (this.plugin.settings.metaCreatedFieldName = p || "created"),
                await this.plugin.saveSettings();
            }),
        );
    let b = new T.Setting(h)
      .setName(c("editTimeFormat"))
      .setDesc(c("editTimeFormatDesc"))
      .addText((u) => {
        u.setValue(this.plugin.settings.metaEditTimeFormat)
          .setPlaceholder("YYYY-MM-DD HH:mm:ss")
          .onChange(async (p) => {
            (this.plugin.settings.metaEditTimeFormat = p),
              await this.plugin.saveSettings();
          });
      });
    b.setDisabled(!this.plugin.settings.metaEditTimeEnabled);
    let x = t.createEl("details", {
      cls: "setting-item-collapse nested-settings",
      attr: { id: "custom-meta-collapse" },
    });
    x.createEl("summary", { text: c("customMetadata") }),
      new T.Setting(x)
        .setName(c("metaSetting"))
        .setDesc(c("customMetadataDesc"))
        .setHeading()
        .addButton((u) =>
          u.setButtonText(c("addField")).onClick(async () => {
            this.plugin.settings.customMetadata.push({ key: "", value: "" }),
              await this.plugin.saveSettings(),
              this.refresh();
          }),
        ),
      this.plugin.settings.customMetadata.forEach((u, p) => {
        new T.Setting(x)
          .addText((w) =>
            w
              .setPlaceholder(c("fieldKey"))
              .setValue(u.key)
              .onChange(async (g) => {
                (this.plugin.settings.customMetadata[p].key = g),
                  await this.plugin.saveSettings();
              }),
          )
          .addText((w) =>
            w
              .setPlaceholder(c("fieldValue"))
              .setValue(u.value)
              .onChange(async (g) => {
                (this.plugin.settings.customMetadata[p].value = g),
                  await this.plugin.saveSettings();
              }),
          )
          .addButton((w) =>
            w.setIcon("trash").onClick(async () => {
              this.plugin.settings.customMetadata.splice(p, 1),
                await this.plugin.saveSettings(),
                this.refresh();
            }),
          );
      });
  }
  refresh() {
    let e = document.getElementById("meta-settings-collapse"),
      t = document.getElementById("custom-meta-collapse"),
      n = e == null ? void 0 : e.open,
      s = t == null ? void 0 : t.open;
    this.display(),
      requestAnimationFrame(() => {
        let a = document.getElementById("meta-settings-collapse"),
          i = document.getElementById("custom-meta-collapse");
        n && a && (a.open = !0), s && i && (i.open = !0);
      });
  }
  addIndexFileSettings() {
    let t = this.containerEl
      .createEl("div")
      .createEl("details", { cls: "setting-item-collapse" });
    t.createEl("summary", { text: c("indexFileSetting") }),
      t
        .createEl("div", { cls: "setting-item-description" })
        .setText(c("indexFileSettingDesc")),
      new T.Setting(t)
        .setName(c("defaultIndexString"))
        .setDesc(c("defaultIndexStringDesc"))
        .addText((s) =>
          s
            .setPlaceholder("index_")
            .setValue(this.plugin.settings.defaultIndexString)
            .onChange(async (a) => {
              (this.plugin.settings.defaultIndexString = a),
                await this.plugin.saveSettings();
            }),
        ),
      new T.Setting(t)
        .setName(c("indexExcludeFile"))
        .setDesc(c("indexExcludeFileDesc"))
        .addText((s) =>
          s
            .setPlaceholder("xxx.md, *_yyy.md default is null")
            .setValue(this.plugin.settings.indexExcludeFile)
            .onChange(async (a) => {
              (this.plugin.settings.indexExcludeFile = a),
                await this.plugin.saveSettings();
            }),
        ),
      new T.Setting(t)
        .setName(c("indexExcludeDir"))
        .setDesc(c("indexExcludeDirDesc"))
        .addText((s) =>
          s
            .setPlaceholder("xxx, *_yyy default is null")
            .setValue(this.plugin.settings.indexExcludeDir)
            .onChange(async (a) => {
              (this.plugin.settings.indexExcludeDir = a),
                await this.plugin.saveSettings();
            }),
        );
  }
  addDonationSettings() {
    let t = this.containerEl
      .createEl("div")
      .createEl("details", { cls: "setting-item-collapse" });
    t.createEl("summary", { text: c("donate") }),
      t
        .createEl("div", { cls: "setting-item-description" })
        .setText(c("donateDesc")),
      new T.Setting(t)
        .setName(c("supportThisPlugin"))
        .setDesc(c("supportThisPluginDesc"))
        .addButton((s) => {
          s.setButtonText(c("bugMeACoffee"))
            .setCta()
            .onClick(() => {
              window.open("https://buymeacoffee.com/xieyan0811y", "_blank");
            });
        });
  }
};
var Q = require("obsidian");
var Gn = require("obsidian");
async function gn(r, e, t, n = !1, s = !0, a = !0, i = !1) {
  let o = !1;
  if (
    (a && (o = await Ri(r, e, t, n, s, i)),
    (await Mi(r, e, t, n)) && (o = !0),
    t.metaEditTimeEnabled)
  )
    try {
      let d = Qs(new Date(), t.metaEditTimeFormat);
      ae(r, e, t.metaUpdatedFieldName, d, "update");
      let f = new Date(r.stat.ctime),
        m = Qs(f, "YYYY-MM-DD");
      ae(r, e, t.metaCreatedFieldName, m, "update"), (o = !0);
    } catch (l) {
      console.error("Update time failed:", l),
        new Gn.Notice(c("llmError") + ": " + l);
    }
  if (t.customMetadata && t.customMetadata.length > 0) {
    for (let l of t.customMetadata)
      if (l.key && l.value) {
        let d = l.value;
        (l.value.toLowerCase() === "true" ||
          l.value.toLowerCase() === "false") &&
          (d = l.value.toLowerCase() === "true"),
          ae(r, e, l.key, d, n ? "update" : "keep");
      }
    o = !0;
  }
  o && s && new Gn.Notice(c("metaUpdated"));
}
async function Xr(r, e, t, n = !1) {
  var f;
  let s = await zs(e, r, t),
    a = (f = e.metadataCache.getFileCache(r)) == null ? void 0 : f.frontmatter,
    i = [],
    o = [];
  if (
    n ||
    !(a != null && a[t.metaTagsFieldName]) ||
    a[t.metaTagsFieldName].length === 0
  ) {
    let m = t.tags.join(",");
    i.push(`1. Tags: ${t.metaTagsPrompt}
   Available tags: ${m}. Feel free to create new ones if none are suitable.`),
      o.push('"tags": "tag1,tag2,tag3"');
  }
  let l = t.categories.join(",") || c("categoryUnknown");
  return (
    i.push(`${i.length + 1}. Category: ${t.metaCategoryPrompt}
   Available categories: ${l}. Must choose ONE from the available categories.`),
    o.push('"category": "category_name"'),
    i.push(`${i.length + 1}. Description: ${t.metaDescription}`),
    o.push('"description": "brief summary"'),
    t.metaTitleEnabled &&
      (i.push(`${i.length + 1}. Title: ${t.metaTitlePrompt}`),
      o.push('"title": "article title"')),
    `I need to generate metadata for the following article. Requirements:

` +
      i.join(`

`) +
      `

Please return in the following JSON format:
{
    ${o.join(`,
    `)}
}

File path: ${r.path}

The article content is as follows:

${s}`
  );
}
async function Ri(r, e, t, n = !1, s = !0, a = !1) {
  var m, y, h, b;
  let i = e.metadataCache.getFileCache(r),
    o = (i == null ? void 0 : i.frontmatter) || {};
  if (
    !(
      !o[t.metaTagsFieldName] ||
      ((m = o[t.metaTagsFieldName]) == null ? void 0 : m.length) === 0 ||
      !o[t.metaDescriptionFieldName] ||
      ((y = o[t.metaDescriptionFieldName]) == null ? void 0 : y.trim()) ===
        "" ||
      (t.metaTitleEnabled &&
        (!o[t.metaTitleFieldName] ||
          ((h = o[t.metaTitleFieldName]) == null ? void 0 : h.trim()) ===
            "")) ||
      (t.metaCategoryEnabled &&
        (!o[t.metaCategoryFieldName] ||
          ((b = o[t.metaCategoryFieldName]) == null ? void 0 : b.trim()) ===
            "")) ||
      n
    )
  )
    return console.warn(c("fileAlreadyContainsTagsAndDescription")), !1;
  let l = await Xr(r, e, t, n),
    d = await se(l, t, s);
  if (
    (a && console.log("callLLM ret:", d),
    d === "" || d === void 0 || d === null)
  )
    return !1;
  d = d.replace(/`/g, "");
  let f = {};
  try {
    let x = d.match(/{[^]*}/);
    x && (f = JSON.parse(x[0]));
  } catch (x) {
    return (
      new Gn.Notice(
        c("parseError") +
          `
` +
          x,
      ),
      console.error("parseError:", x),
      !1
    );
  }
  if (f.tags) {
    let x = f.tags.split(",");
    ae(r, e, t.metaTagsFieldName, x, "append");
  }
  if (f.category && t.metaCategoryEnabled) {
    let x = o[t.metaCategoryFieldName],
      u = !x || x.trim() === "";
    ae(r, e, t.metaCategoryFieldName, f.category, n || u ? "update" : "keep");
  }
  if (f.description) {
    let x = o[t.metaDescriptionFieldName],
      u = !x || x.trim() === "";
    ae(
      r,
      e,
      t.metaDescriptionFieldName,
      f.description,
      n || u ? "update" : "keep",
    );
  }
  if (t.metaTitleEnabled && f.title) {
    let x = f.title.trim();
    ((x.startsWith('"') && x.endsWith('"')) ||
      (x.startsWith("'") && x.endsWith("'"))) &&
      (x = x.substring(1, x.length - 1));
    let u = o[t.metaTitleFieldName],
      p = !u || u.trim() === "";
    ae(r, e, t.metaTitleFieldName, x, n || p ? "update" : "keep");
  }
  return !0;
}
async function Mi(r, e, t, n = !1) {
  if (t.metaCoverEnabled) {
    let s = e.metadataCache.getFileCache(r),
      i = ((s == null ? void 0 : s.frontmatter) || {})[t.metaCoverFieldName],
      o = !i || i.trim() === "";
    if (n || o) {
      let l = t.metaCoverUrl;
      if (t.metaCoverUseFirst) {
        let f = (await e.vault.read(r)).match(/!\[.*?\]\((.*?)\)/);
        f && f[1] && (l = f[1]);
      }
      if (l) return ae(r, e, t.metaCoverFieldName, l, "update"), !0;
    }
  }
  return !1;
}
function Qs(r, e) {
  let t = r.getFullYear(),
    n = String(r.getMonth() + 1).padStart(2, "0"),
    s = String(r.getDate()).padStart(2, "0"),
    a = String(r.getHours()).padStart(2, "0"),
    i = String(r.getMinutes()).padStart(2, "0"),
    o = String(r.getSeconds()).padStart(2, "0");
  return e
    .replace("YYYY", t.toString())
    .replace("MM", n)
    .replace("DD", s)
    .replace("HH", a)
    .replace("mm", i)
    .replace("ss", o);
}
function Di(r) {
  let e = r.replace(/[.+^${}()|[\]\\]/g, "\\$&");
  return (e = e.replace(/\*/g, ".*")), new RegExp(e);
}
function Zs(r, e) {
  if (!e) return !1;
  let t = e
    .split(",")
    .map((n) => n.trim())
    .filter((n) => n !== "");
  for (let n of t) if (Di(n).test(r.path)) return !0;
  return !1;
}
var Yn = class extends Q.Notice {
  constructor(t) {
    super("", 0);
    this.cancelled = !1;
    (this._messageEl = document.createElement("div")),
      setTimeout(() => {
        let n = this.noticeEl;
        if (n) {
          (n.style.display = "flex"),
            (n.style.flexDirection = "column"),
            (n.style.alignItems = "center"),
            (n.style.gap = "8px"),
            (n.style.padding = "8px"),
            (this._messageEl.textContent = t),
            (this._messageEl.style.textAlign = "center"),
            n.appendChild(this._messageEl);
          let s = document.createElement("button");
          (s.textContent = c("cancel")),
            (s.style.minWidth = "60px"),
            (s.style.padding = "4px 8px"),
            s.addEventListener("click", () => {
              (this.cancelled = !0), this.hide();
            }),
            n.appendChild(s);
        }
      }, 0);
  }
  updateMessage(t) {
    this._messageEl.textContent = t;
  }
};
function Kr(r, e, t = !0) {
  var s, a, i;
  let n = e.metadataCache.getFileCache(r);
  return !!(
    (!t && (s = n == null ? void 0 : n.frontmatter) != null && s.description) ||
    (t &&
      (a = n == null ? void 0 : n.frontmatter) != null &&
      a.tags &&
      (i = n == null ? void 0 : n.frontmatter) != null &&
      i.description)
  );
}
async function ea(r, e, t = 10) {
  var n;
  for (let s = 0; s < t; s++) {
    let a = r.metadataCache.getFileCache(e);
    if ((n = a == null ? void 0 : a.frontmatter) != null && n.description)
      return;
    await new Promise((i) => setTimeout(i, 100));
  }
}
async function Gr(r, e, t, n = !0) {
  let s = r.path,
    a = r.name,
    i = `${s}/${t.defaultIndexString}${a}.md`,
    o = e.vault.getAbstractFileByPath(i);
  if (!o || !(o instanceof Q.TFile)) {
    if (!n) return null;
    if (
      (await e.vault.create(i, ""),
      (o = e.vault.getAbstractFileByPath(i)),
      !o || !(o instanceof Q.TFile))
    )
      return console.log("failed to create file"), null;
  }
  return o;
}
async function Yr(r, e, t) {
  let s = e.vault
      .getMarkdownFiles()
      .filter((h) => h.path.startsWith(r.path + "/"))
      .filter((h) => !Zs(h, t.indexExcludeFile)),
    a = e.vault
      .getAllLoadedFiles()
      .filter(
        (h) =>
          (h.path.startsWith(r.path + "/") || h.path === r.path) &&
          h instanceof Q.TFolder &&
          !Zs(h, t.indexExcludeDir),
      );
  a.sort((h, b) => {
    let x = h.path.split("/").length;
    return b.path.split("/").length - x;
  });
  let i = 0,
    o = 0,
    l = 0;
  for (let h of s) {
    let b = Kr(h, e),
      x = ft(h, t);
    if (((i += 1), !b && !x)) {
      o += 1;
      let u = await Xr(h, e, t),
        p = qt(u);
      l += p.length + 100;
    }
  }
  let d = 0;
  if (a.length > 0) {
    for (let h of a) {
      let b = await Gr(h, e, t, !1);
      (b && Kr(b, e, !1)) || (d += 1);
    }
    l += d * 1e3;
  }
  let f = !1;
  if (l > 0) {
    let h = "";
    o > 0 &&
      (h +=
        c("foundFilesNeedProcess")
          .replace("{total}", i.toString())
          .replace("{count}", o.toString()) +
        `

`),
      d > 0 &&
        (h +=
          c("foundDirsNeedIndex").replace("{dirs}", d.toString()) +
          `

`),
      (h += c("estimatedTokens").replace("{tokens}", Math.ceil(l).toString())),
      (f = await pn(e, h, c("extract"), c("skip")));
  }
  if (f === void 0) {
    new Q.Notice(c("processCancelled"));
    return;
  }
  if (o > 0 && f) {
    let h = new Yn(`${c("processingFiles")}: 0/${o}`),
      b = 0;
    for (let x of s) {
      if (h.cancelled) {
        new Q.Notice(c("processCancelled"));
        return;
      }
      let u = Kr(x, e),
        p = ft(x, t);
      !u &&
        !p &&
        (await gn(x, e, t, !1, !1, !0, !0),
        await ea(e, x),
        b++,
        h.updateMessage(`${c("processingFiles")}: ${b}/${o}`));
    }
    h.hide(), await new Promise((x) => setTimeout(x, 500));
  }
  let m = new Yn(`${c("generatingIndex")}: 0/${a.length}`),
    y = 0;
  for (let h of a) {
    if (m.cancelled) {
      new Q.Notice(c("processCancelled")), m.hide();
      return;
    }
    let b = await Ni(h, e, t, f);
    f && b && (await ea(e, b)),
      y++,
      m.updateMessage(`${c("generatingIndex")}: ${y}/${a.length}`);
  }
  m.hide(),
    new Q.Notice(
      c("processCompleteWithIndex")
        .replace("{count}", f ? o.toString() : "0")
        .replace("{dirs}", y.toString()),
    );
}
async function Ni(r, e, t, n = !0) {
  var x, u, p, w;
  let s = [],
    a = e.vault
      .getAllLoadedFiles()
      .filter((g) => g.parent === r && g instanceof Q.TFolder);
  a.sort((g, A) => g.name.localeCompare(A.name));
  for (let g of a) {
    let A = await Gr(g, e, t, !1),
      E = A ? e.metadataCache.getFileCache(A) : null;
    s.push({
      name: g.name,
      path: g.path,
      isDir: !0,
      tags:
        ((x = E == null ? void 0 : E.frontmatter) == null ? void 0 : x.tags) ||
        [],
      description:
        ((u = E == null ? void 0 : E.frontmatter) == null
          ? void 0
          : u.description) || c("noDescription"),
      indexFile: A,
    });
  }
  let i = e.vault
    .getMarkdownFiles()
    .filter((g) => g.parent === r)
    .filter((g) => !ft(g, t));
  i.sort((g, A) => g.basename.localeCompare(A.basename));
  for (let g of i) {
    let A = e.metadataCache.getFileCache(g);
    s.push({
      name: g.basename,
      path: g.path,
      isDir: !1,
      tags:
        ((p = A == null ? void 0 : A.frontmatter) == null ? void 0 : p.tags) ||
        [],
      description:
        ((w = A == null ? void 0 : A.frontmatter) == null
          ? void 0
          : w.description) || c("noDescription"),
      file: g,
    });
  }
  let o = {};
  for (let g of s) for (let A of g.tags || []) o[A] = (o[A] || 0) + 1;
  let l = await Gr(r, e, t);
  if (!l || !(l instanceof Q.TFile))
    return console.log("failed to get file"), null;
  let d = Object.keys(o).sort((g, A) => o[A] - o[g]);
  (d = [c("moc"), ...d]), ae(l, e, "tags", d, "append");
  let f = s.map((g) => {
      if (g.isDir) {
        let A = g.indexFile ? g.indexFile.path.replace(/ /g, "%20") : "";
        return g.indexFile ? `- [${g.name}](${A})` : `- ${g.name}`;
      } else {
        let A = g.path.replace(/ /g, "%20");
        return `- [${g.name}](${A})`;
      }
    }).join(`
`),
    m = s.map((g) => {
      let A =
        g.isDir && g.indexFile ? g.indexFile.path.replace(/ /g, "%20") : g.path;
      return `${g.isDir && g.indexFile ? `- [${g.name}](${A})` : g.isDir ? `- ${g.name}` : `- [${g.name}](${A})`}
  - ${g.description}`;
    }).join(`
`),
    y = await e.vault.read(l),
    h =
      "## " +
      c("fileList") +
      `
` +
      f;
  y = Jr(y, c("fileList"), h);
  let b =
    "## " +
    c("fileDetail") +
    `
` +
    m;
  return (
    (y = Jr(y, c("fileDetail"), b)),
    await e.vault.modify(l, y),
    await gn(l, e, t, !1, !1, n, !1),
    l
  );
}
var ye = require("obsidian");
var zr = class extends ye.SuggestModal {
    constructor(e, t) {
      super(e),
        (this.settings = t),
        (this.inputValue = ""),
        this.modalEl.addClass("folder-suggest-modal");
      let n = this.modalEl.createDiv("dialog-button-container");
      n.addClass("dialog-button-container"),
        n.addClass("right-aligned"),
        (this.confirmButton = n.createEl("button", { text: c("confirm") })),
        this.confirmButton.addEventListener("click", () => {
          this.onConfirm();
        }),
        this.inputEl.addEventListener("input", (s) => {
          this.inputValue = s.target.value;
        }),
        (this.emptyStateText = c("noFolders"));
    }
    onChooseSuggestion(e, t) {}
    onConfirm() {
      Oi(this.inputValue, this.app, this.settings), this.close();
    }
    renderSuggestion(e, t) {
      t.createEl("div", { text: e });
    }
    getSuggestions(e) {
      let t = this.app.vault.getAllFolders();
      t = t.filter((a) => a.path.includes(e));
      for (let a of this.settings.selectExcludedFolders)
        t = t.filter((i) => !i.path.startsWith(a));
      let n = t.map((a) => a.path),
        s = {};
      return (
        n.forEach((a) => {
          let i = (a.match(/\//g) || []).length;
          s[a] = i;
        }),
        n.sort((a, i) => s[a] - s[i]),
        (e === "" || c("allFolders").startsWith(e)) &&
          (n = [c("allFolders"), ...n]),
        n
      );
    }
    handleKeyDown(e) {
      if (e.key === "Tab") {
        let t = this.app.vault.getAllFolders();
        if (
          ((t = t.filter((n) => n.path.startsWith(this.inputEl.value))),
          t.length === 0)
        )
          return;
        this.inputEl.value = t[0].path;
      }
    }
    onOpen() {
      super.onOpen(),
        this.inputEl.addEventListener("keydown", this.handleKeyDown.bind(this));
    }
    onClose() {
      this.inputEl.removeEventListener(
        "keydown",
        this.handleKeyDown.bind(this),
      ),
        super.onClose();
    }
    selectSuggestion(e, t) {
      t.preventDefault(), (this.inputEl.value = e), (this.inputValue = e);
      let n = new InputEvent("input", { bubbles: !0, cancelable: !0 });
      this.inputEl.dispatchEvent(n), this.inputEl.focus();
    }
  },
  Qr = class extends ye.Modal {
    constructor(e, t) {
      super(e), (this.options = t);
    }
    onOpen() {
      let { contentEl: e } = this;
      e.createEl("h2", { text: c("pleaseSelectFolder") });
      let t = e.createEl("ul");
      this.options.forEach((n) => {
        let s = t.createEl("li");
        s.createEl("a", { text: n, attr: { href: "#" } }),
          s.addEventListener("click", (a) => {
            a.preventDefault(), this.close();
            let i = this.app.workspace.getActiveFile();
            if (!i) {
              new ye.Notice(c("pleaseOpenFile"));
              return;
            }
            this.app.vault.rename(i, n + "/" + i.name),
              new ye.Notice(c("migrationSuccess"));
          });
      });
    }
    onClose() {
      let { contentEl: e } = this;
      e.empty();
    }
  };
async function Oi(r, e, t) {
  let n = e.workspace.getActiveFile();
  if (!n) {
    new ye.Notice(c("pleaseOpenFile"));
    return;
  }
  let s = e.vault.getAllFolders();
  if (r !== c("allFolders")) {
    let o = e.vault.getFolderByPath(r);
    if (o == null) {
      new ye.Notice(c("folderNotFound") + r);
      return;
    }
    s = s.filter((l) => o && l.path.startsWith(o.path));
  }
  for (let o of t.selectExcludedFolders)
    s = s.filter((l) => !l.path.startsWith(o));
  let a = [];
  if (s.length >= 100) {
    let o = `"${r}" ${c("tooManyFolders_1")}${s.length}${c("tooManyFolders_2")}`;
    if (!(await pn(e, o))) return;
  }
  if (s.length <= 3) a = s.map((o) => o.path);
  else {
    let o = n.basename,
      l = e.metadataCache.getFileCache(n),
      d = "";
    l != null &&
    l.frontmatter !== null &&
    l.frontmatter !== void 0 &&
    l.frontmatter.description
      ? (d = `The current file name is: '${o}'. The description is: '${l.frontmatter.description}'.`)
      : (d = `The current file name is: '${o}'.`),
      (d += `
Please help me find the three most suitable directories for storing this file, and return only the directory paths, separated by line breaks.

Below is the list of directory paths:
${s.map((m) => m.path).join(`
`)}
`);
    let f = await se(d, t);
    if (f === "" || f === void 0 || f === null) {
      new ye.Notice(c("noResult"));
      return;
    }
    (f = f.replace(/`/g, "")),
      (f = f.trim()),
      (a = f.split(`
`)),
      (a = a.map((m) => m.trim()));
  }
  new Qr(e, a).open();
}
async function ta(r, e) {
  let t = new zr(r, e);
  t.setPlaceholder(c("searchDesc")), t.open();
}
var Se = require("obsidian");
function na(r) {
  var t;
  let e =
    (t = r.workspace.getActiveViewOfType(Se.MarkdownView)) == null
      ? void 0
      : t.editor;
  return e ? e.getSelection() : "";
}
function ki(r, e) {
  let t = e
    ? Object.fromEntries(Object.entries(r).filter(([n]) => n.includes(e)))
    : r;
  return Object.keys(t).sort((n, s) => nr(t, n, s));
}
var zn = class extends Se.SuggestModal {
    constructor(e, t) {
      super(e), (this.plugin = t);
    }
    onOpen() {
      let { inputEl: e } = this;
      (e.type = "text"),
        (e.placeholder = c("inputPrompt")),
        this.inputEl.dispatchEvent(new Event("input")),
        (this.limit = 30);
    }
    getSuggestions(e) {
      let t = this.plugin.settings,
        n = ki(t.llmPrompts, e);
      return n.length === 0 ? [e] : n;
    }
    renderSuggestion(e, t) {
      t.createEl("div", { text: e }).addClass("custom-suggestion-item");
    }
    onChooseSuggestion(e, t) {
      if (e === "") {
        new Se.Notice(c("inputPrompt"));
        return;
      }
      ra(e, this.app, this.plugin);
    }
  },
  Zr = class extends zn {
    constructor(e, t) {
      super(e, t), this.modalEl.addClass("folder-suggest-modal");
      let n = this.modalEl.createDiv("dialog-button-container");
      n.addClass("dialog-button-container"),
        n.addClass("right-aligned"),
        (this.chatButton = n.createEl("button", { text: c("chatButton") })),
        this.chatButton.addEventListener("click", () => this.triggerChat());
    }
    onChooseSuggestion(e, t) {}
    selectSuggestion(e, t) {
      t.preventDefault(), (this.inputEl.value = e);
      let n = new InputEvent("input", { bubbles: !0, cancelable: !0 });
      this.inputEl.dispatchEvent(n), this.inputEl.focus();
    }
    triggerChat() {
      let e = this.inputEl.value;
      if (e === "") {
        new Se.Notice(c("inputPrompt"));
        return;
      }
      ra(e, this.app, this.plugin), this.close();
    }
  };
async function ra(r, e, t) {
  var l;
  let n = t.settings,
    s = na(this.app),
    a = `Prompt:
${r}

Content:
${s}`,
    i = await se(a, n),
    o =
      (l = e.workspace.getActiveViewOfType(Se.MarkdownView)) == null
        ? void 0
        : l.editor;
  o &&
    (o.replaceSelection(
      s +
        `

` +
        i +
        `
`,
    ),
    await rr(t, r, 1));
}
async function sa(r, e) {
  if (na(r) === "") {
    new Se.Notice(c("pleaseSelectText"));
    return;
  }
  e.settings.llmDialogEdit ? new Zr(r, e).open() : new zn(r, e).open();
}
var Qn = require("obsidian");
async function aa(r, e) {
  var f;
  let t =
    (f = r.workspace.getActiveViewOfType(Qn.MarkdownView)) == null
      ? void 0
      : f.editor;
  if (!t) return;
  let n = t.getSelection();
  if (!n) {
    new Qn.Notice(c("pleaseSelectText"));
    return;
  }
  let a = n
      .split(
        `
`,
      )
      .filter((m) => m.trim() !== ""),
    i = t.getValue();
  i.replace(n, "");
  let o = `
Please insert the following content into the appropriate place in the main text. Return the modified main text, and enclose the inserted content with double equals signs (==).
The content to be inserted is as follows:
${a.join(`
`)}
The markdown main text is as follows:
${i}
`,
    l = await se(o, e);
  if (l === "" || l === void 0 || l === null) return;
  let d = l.match(/```markdown\s*([\s\S]*?)\s*```/);
  d && (l = d[1]),
    t.setValue(
      l +
        `

` +
        c("insertContent") +
        `

` +
        n,
    );
}
var ia = require("obsidian");
async function oa(r, e) {
  let t = r.workspace.getActiveViewOfType(ia.MarkdownView);
  if (!t) return;
  let n = t.editor,
    s = n.getCursor(),
    a = n.getSelection(),
    i = [],
    o = [],
    l;
  if (a) (i = [a]), (l = n.getCursor("to"));
  else {
    let p = n.getLine(s.line);
    for (let I = Math.max(0, s.line - 2); I < s.line; I++) {
      let R = n.getLine(I);
      R.trim() && i.push(R);
    }
    let w = p.substring(0, s.ch);
    w.trim() && i.push(w);
    let g = p.substring(s.ch);
    g.trim() && o.push(g);
    let A = 0,
      E = s.line + 1;
    for (; E < n.lineCount() && A < 2; ) {
      let I = n.getLine(E);
      I.trim() && (o.push(I), A++), E++;
    }
    l = s;
  }
  let d = 100,
    f = 100,
    m = i.join(" ").trim(),
    y = o.join(" ").trim(),
    h = m.length > d ? "..." + m.slice(-d) : m,
    b = y.length > f ? y.slice(0, f) + "..." : y,
    x = `Previous text: ${h}
Following text: ${b}`,
    u =
      "Complete current sentence or generate a sentence (less than 50 words), based on the context:";
  try {
    let p = [
        "\u280B",
        "\u2819",
        "\u2839",
        "\u2838",
        "\u283C",
        "\u2834",
        "\u2826",
        "\u2827",
        "\u2807",
        "\u280F",
      ],
      w = 0,
      g = l;
    n.replaceRange(" ", g, g);
    let A = setInterval(() => {
        let D = { line: g.line, ch: g.ch + 1 };
        n.replaceRange(p[w], g, D), (w = (w + 1) % p.length);
      }, 100),
      E = await se(
        `${u}

${x}`,
        e,
        !1,
      );
    clearInterval(A), n.replaceRange("", g, { line: g.line, ch: g.ch + 1 });
    let I = g;
    n.replaceRange(E, I, I);
    let R = { line: l.line, ch: l.ch + E.length };
    n.setSelection(I, R);
  } catch (p) {
    console.error("Error generating next sentence:", p);
  }
}
var Zn = class extends Je.Plugin {
  async onload() {
    await this.loadSettings(),
      this.addCommand({
        id: "adjust-meta",
        name: c("exmemoAdjustMeta"),
        editorCallback: (e, t) => {
          this.adjustCurrentFileMeta(this.app, this.settings);
        },
      }),
      this.addCommand({
        id: "insert-dir",
        name: c("exmemoSelectFolder"),
        editorCallback: (e, t) => {
          ta(this.app, this.settings);
        },
      }),
      this.addCommand({
        id: "insert-md",
        name: c("exmemoInsertMd"),
        editorCallback: (e, t) => {
          aa(this.app, this.settings);
        },
      }),
      this.addCommand({
        id: "llm-assistant",
        name: c("exmemoLLMAssistant"),
        editorCallback: (e, t) => {
          sa(this.app, this);
        },
      }),
      this.addCommand({
        id: "generate-next",
        name: c("exmemoGenerateNext"),
        editorCallback: (e, t) => {
          oa(this.app, this.settings);
        },
      }),
      this.addSettingTab(new Kn(this.app, this)),
      this.registerEvent(
        this.app.workspace.on("file-menu", (e, t) => {
          t instanceof Je.TFolder &&
            e.addItem((n) => {
              n.setTitle(c("createIndex"))
                .setIcon("plus")
                .onClick(async () => {
                  await Yr(t, this.app, this.settings);
                });
            });
        }),
      );
  }
  onunload() {}
  async loadSettings() {
    this.settings = Object.assign({}, rs, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async adjustCurrentFileMeta(e, t) {
    var a;
    let n = e.workspace.getActiveFile();
    if (!n) {
      new Je.Notice(c("pleaseOpenFile"));
      return;
    }
    if (n.extension !== "md") {
      new Je.Notice(c("currentFileNotMarkdown"));
      return;
    }
    let s = t.metaUpdateMethod === "force";
    if (ft(n, t)) {
      let i =
        (a = e.vault.getAbstractFileByPath(n.path)) == null ? void 0 : a.parent;
      i instanceof Je.TFolder && (await Yr(i, e, t));
    } else await gn(n, e, t, s, !0, !0, !1);
  }
};

/* nosourcemap */
